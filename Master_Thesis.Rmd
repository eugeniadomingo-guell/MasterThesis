---
title: "Master's Thesis Code"
author: "Eugènia Domingo Güell"
date: "09/09/2025"
output: 
  html_document:
    highlight: default
    number_sections: yes
    theme: readable
    toc: yes
    tec_depth: 2
    toc_float: TRUE
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)

#Reading files
library(readxl)
library(data.table)
library(openxlsx)
library(readr)

#Data manipulation
library(dplyr)
library(tidyr)
library(tidyverse)
library(plyr)
library(stringr)

#Generating tables and plots
library(ggplot2)
library(knitr)
library(graphics)
library(RColorBrewer) 
library(ggpubr)
library(ggnewscale)
library(tidyr)
library(plyr)
library(paletteer)
library(ggfortify)
library(pheatmap)
library(microbiomeutilities)
library(dendextend)
library(ggrepel)
library(ComplexHeatmap)
library(circlize)
library(gplots)
library(ggbio)
library(ggdendro)
library(factoextra)
library(gtable)
library(kableExtra)
library(DT)
library(gt)
library(gtsummary)
library(scales)
library(ggrepel)

#Stats
library(stats)
library(lmtest)
library(pgirmess)
library(vegan)

#Transcriptomics
library(DESeq2)
library(edgeR)
library(limma)
library(GSEABase)
library(msigdbr)
library(GOstats)
library(GO.db)
library(org.Hs.eg.db)
library(clusterProfiler)
library(enrichplot)
library(GSVA)
library(AnnotationDbi)
library(biomaRt)
library(taxize)
library(taxonomizr)
library(immunedeconv)
library(pdacR)
library(airway)
library(BiocStyle)
library(MultiAssayExperiment)
library(SummarizedExperiment)
library(RaggedExperiment)
library(S4Vectors)
library(IRanges)
library(GenomicRanges)
library(ggbio)
library(sva)
library(NMF)

#Microbiome
library(dada2)
library(phyloseq)
library(Biostrings)
library(vegan)
library(microbiome)
library(ANCOMBC)
library(DECIPHER)
library(phangorn)
library(taxize)
library(stringr)
library(taxonomizr)
library(MiscMetabar)
library(microbiomeMarker)
library(FactoMineR)

#MFA
library(FactoMineR)
library(factoextra)
library(mixOmics)
library(caret)


setwd("/set/to/working/directory/")

## Defining a color code for the groups of samples: 
colors_sam <- c("Adjacent" = "#8DBBDC", "Control" = "#358747", "Tumor" = "#C81518", "Patient" = "#C590B3")
colors_bailey <- c("Progenitor" = "orange", "Squamous" = "steelblue", "Immunogenic" = "red3", "ADEX" = "saddlebrown")

```

# Data

## Metadata 

```{r loading metadata, echo=FALSE}
# Loading metadata
mapping_file <- read.delim("/set/to/working/directory//mapping_file.tsv")  #127 patients
## Homogenizing metadata with metadata from microbiome analysis
cnagID <- read.delim("/set/to/working/directory/cnagID.txt")
samples <- read.delim("/set/to/working/directory/samples.txt")
```

```{r preparing metadata, echo=FALSE}
# IDs from the individuals and metadata
IDs_ge <- cnagID[ , c("MULTIPLEX.INDEX", "SAMPLE.NAME", "SAMPLE.BARCODE")]
IDs_ge <- IDs_ge[!duplicated(IDs_ge$SAMPLE.BARCODE), ]
IDs_ge$MULTIPLEX.INDEX <- sub("^([0-9]+UDI).*", "\\1", IDs_ge$MULTIPLEX.INDEX)

# swap probably wrong labelled samples ABA31346 & ABA31347 101UDI and 113UDI
id1 <- IDs_ge$MULTIPLEX.INDEX[grep("ABA31347", IDs_ge$SAMPLE.BARCODE)] ### 113UDI
id2 <- IDs_ge$MULTIPLEX.INDEX[grep("ABA31346", IDs_ge$SAMPLE.BARCODE)] ### 101UDI

IDs_ge$MULTIPLEX.INDEX[grep("ABA31347", IDs_ge$SAMPLE.BARCODE)] <- id2
IDs_ge$MULTIPLEX.INDEX[grep("ABA31346", IDs_ge$SAMPLE.BARCODE)] <- id1


IDs_FF <- samples[ , c("SAMPLE.BARCODE", "ID_microomics", "group_ctl_N_T", "sexo", "Hospital")]
IDs_FF$group_ctl_N_T <- as.factor(IDs_FF$group_ctl_N_T)
levels(IDs_FF$group_ctl_N_T) <- c("Control", "Normal_paired", "Tumor", "Adjacent")
IDs_FF$group_ctl_N_T [IDs_FF$group_ctl_N_T == "Normal_paired"] <- "Adjacent"  ## Assigning proper name to the level
IDs_FF$Hospital <- ifelse(IDs_FF$group_ctl_N_T == "Control", "Bellvitge", IDs_FF$Hospital)

IDs_FF$sexo <- as.factor(IDs_FF$sexo)

metadata_ge <- merge(IDs_ge, IDs_FF, by= "SAMPLE.BARCODE")

# Metadata 
metadata <- metadata_ge[!(metadata_ge$ID_microomics == ""), ]
metadata <- metadata [, ! colnames(metadata) %in% c("SAMPLE.BARCODE")]
colnames(metadata) <- ifelse(colnames(metadata) == "sexo", "Sex", colnames(metadata))
metadata$Sex <- ifelse(metadata$Sex == "Hombre", "Male", "Female")
metadata$Sex <- as.factor(metadata$Sex)
colnames(metadata) <- ifelse(colnames(metadata) == "group_ctl_N_T", "Group", colnames(metadata))
colnames(metadata) <- ifelse(colnames(metadata) == "ID_microomics", "FF_ID", colnames(metadata))

```

```{r determining age, echo=FALSE}
# Determining age:
## Cases:
Casos_pancrees <- read.csv("/set/to/working/directory/Casos_pancrees_Eugenia.csv")
casospancrees <- Casos_pancrees[ , c("id_pancreas", "num_banc_tumors", "num_biopsia", "id_micropanc", "sex", "birth_date", "surgery_date", "hospital")]

casospancrees$birth_date <- as.Date(casospancrees$birth_date)
casospancrees$surgery_date <- as.Date(casospancrees$surgery_date)
casospancrees$Age <- as.numeric(difftime(casospancrees$surgery_date, casospancrees$birth_date, units = "days")) / 365.25
casospancrees$Age <- floor(casospancrees$Age)

ids_find_bt <- casospancrees[ , c("Age", "num_banc_tumors")]
ids_find_bt <- ids_find_bt[!is.na(ids_find_bt$num_banc_tumors), ]  #36 patients
ids_find_biop <- casospancrees[ , c("Age", "num_biopsia")]
ids_find_biop$num_biopsia[ids_find_biop$num_biopsia == ""] <- NA
ids_find_biop <- ids_find_biop[!is.na(ids_find_biop$num_biopsia), ] #111 patients
ids_find_mp <- casospancrees[ , c("Age", "id_micropanc")]
ids_find_mp$id_micropanc[ids_find_mp$id_micropanc == ""] <- NA
ids_find_mp <- ids_find_mp[!is.na(ids_find_mp$id_micropanc ), ] #22 patients

metadata$PatientID <- gsub("_T", "", metadata$SAMPLE.NAME)
metadata$PatientID <- gsub("[TN]", "", metadata$PatientID)
metadata$PatientID <- sub(".*(B20.*)", "\\1", metadata$PatientID)
metadata$PatientID <- sub(".*(MF21.*)", "\\1", metadata$PatientID)
metadata$PatientID[metadata$PatientID == "44-08"] <- "44-09"
metadata$SAMPLE.NAME[metadata$SAMPLE.NAME == "44-08"] <- "44-09"
ids_find_mp$id_micropanc <- gsub("^MBP*", "MB00", ids_find_mp$id_micropanc)

ids_match <- merge(metadata, ids_find_bt, by.x = "PatientID", by.y= "num_banc_tumors", all.x = TRUE, all.y =FALSE)
ids_match <- ids_match %>% left_join(ids_find_biop, by = c("PatientID" = "num_biopsia")) %>%
  mutate( Age = coalesce(Age.x, Age.y)) %>% dplyr::select (-Age.x, -Age.y)
ids_match <- ids_match %>% left_join(ids_find_mp, by = c("PatientID" = "id_micropanc")) %>% 
  mutate ( Age = coalesce (Age.x, Age.y)) %>% dplyr::select(-Age.x, -Age.y)


## Age for CONTROLS:
FFIDs_ages <- read.csv("/set/to/working/directory/FFIDs_ages.csv", sep=";")
Controls_ages <- read.csv("/set/to/working/directory/Controls_ages.csv", sep=";")

ages_controls <- merge(FFIDs_ages, Controls_ages, by.x  ="Codigo.origen", by.y = "mostra")
ages_controls <- ages_controls[, colnames(ages_controls) %in% c("Codigo.origen", "ID_microomics", "Edat")]
ages_controls$Codigo.origen <- gsub("/", "-", ages_controls$Codigo.origen)

ids_match <- ids_match %>% left_join(ages_controls, by = c("FF_ID" = "ID_microomics")) %>% 
  mutate ( Age = coalesce (Age, Edat)) %>% dplyr::select(-Edat, -Codigo.origen)


metadata_final <- ids_match
metadata_final <- metadata_final[, colnames(metadata_final) %in% c("PatientID", "MULTIPLEX.INDEX", "FF_ID", "Group", "Sex", "Hospital", "Age")]
```

```{r final metadata, echo=FALSE}
## FINAL METADATA: 
metadata_final$Group <- as.factor(metadata_final$Group)
metadata_final$Sex <- as.factor (metadata_final$Sex)
metadata_final$Hospital <- as.factor (metadata_final$Hospital)
metadata_final$Age <- as.numeric(metadata_final$Age)

# Scaling age
metadata_final$Age_scaled <- scale(metadata_final$Age)

metadata_final
#write.csv(metadata_final, "/set/to/working/directory/metadata_final.csv")

```


## Participants

```{r participants, echo = FALSE}
### Determining participants in this study:
meta_part <- metadata_final[! duplicated(metadata_final$PatientID), ]    #### 86 individuals are participating in the study
meta_part$Group <- ifelse(meta_part$Group == "Control", "Control", "Patient")

#write.csv(meta_part, "/set/to/working/directory/metadata_participants.csv")
```


### Group 

```{r participants group, echo = FALSE}
### Determining participants in this study:
meta_part$Group <- as.factor(meta_part$Group)
table(meta_part$Group) ## 32 Controls and 54 Patients. 
```

### Sex

```{r sex of the participants, echo = FALSE}
### Determining sex of the participants in this study:
meta_part$Sex <- as.factor(meta_part$Sex)
table(meta_part$Sex) # Female = 39,  Male = 47

### Determining differences in the group of the patients based on the sex. 
Xsq_table_sex <- table(meta_part$Group, meta_part$Sex)
Xsq_sex <- chisq.test(Xsq_table_sex) ### Chi-squared test, p-value = 0.3673

sex_by_group <- ggplot(meta_part, aes(x = Sex, fill = Group)) + 
  geom_bar(position = "dodge", color = "black", lwd = 0.3) + 
  theme_minimal() +
  scale_fill_manual(values = colors_sam) +
  xlab("Sex") + ylab("Frequency") + ggtitle("Diagnose of participants based on Sex") + ylim(c(0, 29)) +
  annotate("text", x = 1.5, y = Inf, label = paste("Chi squared p-val =", round(Xsq_sex$p.value, 3), "(ns)"), vjust = 1.5, size = 4)

plot(sex_by_group)  
```

### Age

```{r age of the participants, echo = FALSE}
### Determining sex of the participants in this study:
meta_part$Age <- as.numeric(meta_part$Age)
summary(meta_part$Age)

mean(meta_part[meta_part$Group == "Patient", ]$Age)  # 67.51852
sd(meta_part[meta_part$Group == "Patient", ]$Age)   # 10.43532
range(meta_part[meta_part$Group == "Patient", ]$Age) # 40 to 86 years old

mean(meta_part[meta_part$Group == "Control", ]$Age)   # 56.6875
sd(meta_part[meta_part$Group == "Control", ]$Age)   # 14.49458
range(meta_part[meta_part$Group == "Control", ]$Age)  # 17 to 80 years old

shapiro.test(meta_part$Age[meta_part$Group == "Control"]) #p-value = 0.009091
shapiro.test(meta_part$Age[meta_part$Group == "Patient"]) #p-value = 0.02125
shapiro.test(meta_part$Age) #p-value = 0.0001026
### Non - parametric tests for the analysis 

wilcox.test(meta_part$Age ~ meta_part$Group) # p-value 0.0001925 - Significant differences on the age based on groups

#Histogram of age based on group
meta_part %>%
  ggplot( aes(x=Age, fill=Group, color=Group)) +
  geom_histogram(alpha=0.8 , color= "black", lwd = 0.2, binwidth = 1) +
  theme_minimal() +
  ggtitle("Age distribution based on Diagnose of the participants") + 
  xlab ("Age") + ylab("Density") + 
  scale_y_continuous(breaks = seq(0, 12, 2)) +
  scale_fill_manual(values = colors_sam)

#Boxplots of age based on group
age_to_group_all <- ggplot(meta_part, aes(x = Group, y = Age, color = Group, fill = Group)) +
  geom_jitter(width = 0.2, size = 3, alpha = 0.7) +  
  geom_boxplot(alpha = 0.2, outlier.shape = NA, color = "black") +  
  theme_minimal() + scale_color_manual(values= colors_sam) + scale_fill_manual(values = colors_sam) +
  labs(title = "Age Distribution by Group", y = "Age", x = "Group") +
  theme(legend.position = "right") + stat_compare_means()

plot(age_to_group_all)


### Scaling age 
meta_part$Age_scaled <- scale(meta_part$Age)

scaledage_to_group_all <- ggplot(meta_part, aes(x = Group, y = Age_scaled, color = Group, fill = Group)) +
  geom_jitter(width = 0.2, size = 3, alpha = 0.7) +  # scatter effect
  geom_boxplot(alpha = 0.2, outlier.shape = NA, color = "black") +  # optional for context
  theme_minimal() + scale_color_manual(values= colors_sam) + scale_fill_manual(values = colors_sam) +
  labs(title = "Scaled Age Distribution by Group", y = "Scaled Age", x = "Group") +
  theme(legend.position = "right") + stat_compare_means()
plot(scaledage_to_group_all)

```



# Gene Expression

```{r loading rnaseq data, echo=FALSE}
### Loading Raw counts: 
rawCounts <- read.delim("/set/to/working/directory/rawCounts", row.names=1, check.names = FALSE)
### Loading TPM counts:
TPM_counts <- read.delim("/set/to/working/directory/TPM_counts", row.names=1, check.names = FALSE)
```


```{r manipulating raw counts, echo=FALSE}
#Raw counts with ALL the participants:
rawCounts_2 <- rawCounts

cols_out<- colnames(rawCounts_2)[!(colnames(rawCounts_2) %in% metadata_final$MULTIPLEX.INDEX)] 
rawCounts_2 <- rawCounts_2[ , ! colnames(rawCounts_2) %in% cols_out]

multi_to_FF <- setNames(metadata_final$FF_ID, metadata_final$MULTIPLEX.INDEX)
colnames(rawCounts_2) <- multi_to_FF[colnames(rawCounts_2)]

### RawCounts with FF IDs
#write.csv(rawCounts_2, "/set/to/working/directory/RawCounts2.csv")

```


```{r example table raw counts, echo=FALSE, cache=TRUE, warning=FALSE}
#Raw counts
example_counts <- kable(
  rawCounts_2[1:5, 1:5],
  format = "html",
  caption = "Table 1: Example of RNA-seq raw counts for 5 genes and 5 samples.") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = FALSE)

```


## Exploring the raw data

Firstly, the library size was studied (total of reads per sample). The values of the total reads per sample range from 8.873833 million to 62.186188 million reads between different samples. 

```{r library size exploring}
#As part of exploration, get library size (total of reads per sample)
ls <- apply(rawCounts_2, 2, sum)/10^6 #apply the sum of values in each row. 
range_ls <- range(ls)  #  8.873833 62.186188

#The values of the total reads per sample vary from 8.873833 reads to 62.186188 between different samples. 
sampleTDF <- data.frame(sample=names(ls), total=ls)

#Plotting the dimensions of the library size in each sample
pls <- ggplot(aes(x=sample, y=ls, fill=ls), data=sampleTDF) + geom_bar(stat="identity") + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1, size= 4)) + ylab("Library size (millions)") + xlab("Samples") + ggtitle("Library Sizes from Samples") + scale_fill_gradient(name = "Library Size") + theme_minimal()

# Detect which sample is the one that has a ls = 62.186188
sampleTDF$total <- as.numeric(sampleTDF$total)
ls_max <- sampleTDF[which.max(sampleTDF$total), ]  ### sample FF90

pls
```


## Filtering

It is important to remove genes that consistently have zero or very low counts. Only the genes that have at least 10 reads in at least 10 samples will be kept to continue with the analysis. Moreover, the genes that do not have variability will be filtered out, as these are not interesting in a differential expression analysis. The genes with a coefficient of variation inside the top 75% quartile were kept for the analysis.

```{r Filtering, echo=TRUE, eval=TRUE, cache=TRUE}
genes_before_fil <- nrow(rawCounts_2) # 58311 genes from the initial data, with n = 124. 
## Filtering by genes not having enough reads
keep <- rowSums(rawCounts_2 > 10) >= 10 
#At least 10 samples have 10 reads per gene --> I will keep the genes that have more than 10 reads in at least 10 samples. 
counts_filtered <- rawCounts_2[keep,] 

## Improving the filtering by coefficient of variation:
cv_filter <- function(x) sd(x) / mean(x)
mrna_filt_cv <- apply(counts_filtered, 1, cv_filter) #Applying to rows: genes
threshold_mrna <- quantile(mrna_filt_cv, 0.25)  # top 75% coefficient of variation genes
mrna_filt_f <- counts_filtered[mrna_filt_cv > threshold_mrna, ]
# head(mrna_filt_f)
n_genes_final <- dim(mrna_filt_f) #17256 genes (ENSEMBL IDs), 124 samples

counts_filt_f <- data.frame(lapply(mrna_filt_f, as.integer), row.names = rownames(mrna_filt_f))
colnames(counts_filt_f) <- gsub("^X", "", colnames(counts_filt_f))

genes_after_fil_1 <- nrow(counts_filtered)  #23009 genes after the filtering
genes_after_fil_2 <- nrow(counts_filt_f)   # 17256 genes 

rejected_genes <- nrow(rawCounts_2)-nrow(counts_filt_f) 
#41055 genes were rejected because they had less than 10 reads in at least 10 samples and presented low variability between samples (on the quartile 25) --> coefficient of variation

table_filtered_genes <- data.frame(genes_before_fil, genes_after_fil_1, genes_after_fil_2, rejected_genes)
table_filt_genes_html <- table_filtered_genes %>% kable(
    caption = "Table 2: Nº of Genes during Filtering Process",
    col.names = c("Nº of Genes - Before Filtering", "After Filtering - Low Count", "After Filtering - Low Variability", "Discarded by Filtering")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
table_filt_genes_html
```


## Normalization

**TMM** (Trimmed Mean on the M-values) is a method to normalize values in RNA-seq count matrices. It is used to correct the imbalance caused by the composition bias (genes that accumulate high rates of reads). This method is suitable to compare among samples, when performing sample aggregations, and is the standard procedure to report results. There are situations in which some genes accumulate high rates of reads (composition bias), and TMM normalization is used to correct the imbalance. In this analysis, TMM normalization method was used.

```{r TMM, echo=TRUE, eval=TRUE, cache=TRUE}
#Normalization using TMM
d <- DGEList(counts = counts_filt_f)
Norm.Factor <- calcNormFactors(d, method = "TMM")
countsTMM <- cpm(Norm.Factor, log = T)  #log = TRUE 
countsTMM_head <- (countsTMM)[1:5, 1:5]

countsTMM.df <- as.data.frame(countsTMM) # 124 samples and 17256 genes
rownames(countsTMM.df) <- gsub("\\..*$", "", rownames(countsTMM.df))
#write.csv(countsTMM.df, "/set/to/working/directory/normalized_counts.csv")

```

## Sample Aggregation

### Hierarchical Clustering

The purpose of the hierarchical clustering is to see whether samples aggregate by sex or group of patients, or if there are other variables affecting the distribution of the samples (that can be due to biological or technical causes). The TMM normalized values will be used, which allow the comparison between samples.

```{r Sample Aggregation Hierarchical Clusering, echo=TRUE, eval=TRUE, cache=TRUE}
#Assigning the sex and group to the name of the samples for the hierarchical clustering df
meta_pca <- metadata_final
x<-countsTMM

meta_pca$sgid <- ifelse(metadata_final$Sex == "Male", 
                          ifelse(metadata_final$Group == "Control", "M_C",
                          ifelse(metadata_final$Group == "Adjacent", "M_A",
                          ifelse(metadata_final$Group == "Tumor", "M_T", NA))),
                      ifelse(metadata_final$Group == "Control", "F_C",
                      ifelse(metadata_final$Group == "Adjacent", "F_A",
                      ifelse(metadata_final$Group == "Tumor", "F_T", NA))))
meta_pca <- meta_pca[match(colnames(x), meta_pca$FF_ID), ]
identical(colnames(x), meta_pca$FF_ID) ### True

colnames(x) <- meta_pca$sgid
#   x

#Euclidean distance
clust.cor.ward <- hclust(dist(t(x)),method="ward.D2")

label_colors_sex <- ifelse(startsWith(labels(as.dendrogram(clust.cor.ward)), "F"), "#9857A4", "#D87B00")
label_colors_group <- ifelse(grepl("_T", labels(as.dendrogram(clust.cor.ward))), "#C81518",       
                 ifelse(grepl("_A", labels(as.dendrogram(clust.cor.ward))), "#6AB1D6",     
                        "#2C7E41"))

d <- as.dendrogram(clust.cor.ward)

d_sex <- d 
labels_colors(d_sex) <- label_colors_sex
labels_cex(d_sex) <- 0.4


d_group <- d 
labels_colors(d_group) <- label_colors_group
labels_cex(d_group) <- 0.4



plot(d_sex, main= "Dendrogram of samples", xlab="Ward.D2 Clustering of Samples - colored by Sex", )
legend("topright", legend = c("Female", "Male"), col = c("#9857A4", "#D87B00"), pch = 15, pt.cex = 1.5, bty = "n", cex = 0.8)

plot(d_group, main= "Dendrogram of samples", xlab="Ward.D2 Clustering of Samples - colored by Group")
legend("topright", legend = c("Control", "Adjacent", "Tumor"), col = c("#2C7E41", "#6AB1D6", "#C81518"), pch = 15, pt.cex = 1.5, bty = "n", cex = 0.8)

plot(clust.cor.ward, main="Hierarchical clustering", hang=-1,cex=0.4, )
```


### PCA

Principal Components Analysis is a statistical technique used to reduce dimensions of a data set, in order to capture most of the variability of the dataset in some factors named "Principal Components" (PC). The first two PC usually capture most of the variability of the system and can be represented in a 2-dimensional space. The resulting 2D plot is useful to observe possible clustering of the samples by determined factors.

```{r PCA, echo=TRUE}
metadata_final <- read.csv("/set/to/working/directory/metadata_final.csv", row.names=1)
metadata_final$Group <- as.factor(metadata_final$Group)
metadata_final$Sex <- as.factor(metadata_final$Sex)
metadata_final$Age <- as.numeric(metadata_final$Age)

metadata_final[order(metadata_final$FF_ID), ]
rawCounts_2[,order(colnames(rawCounts_2))]

summary_PCA <- summary(pca.filt <- prcomp(t(counts_filt_f[, order(colnames(counts_filt_f))]), scale=T, center = T)) 
PC1_PC2 <- 25.53 + 9.34 # 34.87 %
PCA_general <- autoplot(pca.filt, data=metadata_final[order(metadata_final$FF_ID), ], colour="Group", shape = "Sex") + ggtitle("Principal Component Analysis ")  + scale_colour_manual(values= colors_sam) + theme_minimal() + stat_ellipse(aes(group = Group, color=Group), level = 0.95, alpha = 0.4)

plot(PCA_general)
```


## Differential Gene Expression Analysis

Differential gene expression (DGE) analysis is one of the most used techniques for RNA-sequencing (RNA-seq) data analysis. DGE allows the identification of differential expressed genes (DEGs) across two (or more) sample sets. Functional enrichment analyses can be further performed to annotate the genes and biologically contextualize them within their corresponding pathways. These studies provide valuable information about disease-causing biological processes and can help to identify molecular targets for novel therapies, particularly for the identification of biomarkers for precision medicine and drug discovery. [@rosati2024].

There are different methods by which it is possible to perform DGE analysis. Depending on the method, the data needs to be pre-processed. Some of the possible different tools are: DESeq2, voom + limma, DEGseq, edgeR, NOIseq, etc.


### DESeq2

DESeq2 is a popular method to perform differential gene expression analysis on RNA-seq data, to analyze the systematic changes across experimental conditions. It is a method that uses shrinkage estimation for dispersions and fold changes to improve stability and interpretability of estimates. Small replicate numbers, discreteness, large dynamic range and the presence of outliers require a suitable statistical approach that DESeq2 provides. [@love2014].

The package `DESeq2` was installed from BioConductor, and used in R (version 4.4.1). It provides methods to test for differential expression by use of negative binomial generalized linear models.

As input, the DESeq2 package expects raw count data in the form of a matrix of integer values: one row for each gene and one column for each sample. The DESeq2 model internally corrects for library size, so transformed or normalized values such as counts scaled by library size should not be used as input. That's why we don not use the TMM normalized data set. The data used in this step is the filtered data set.

A typical analysis through `DESeq2` comprises three steps:

1.  Creation of a `DESeqDataSet` object that contains the raw counts matrix, sample variables and design formula.
2.  Differential expression analysis, performed with function `DESeq` from the `DESeq2` package.
3.  Results extraction using the `results` function, where contrasts can be specified.

The columns of the counts matrix and the rows of the variables (about the samples) need to be in the same order.

```{r DESeq2, echo=T, include = T, message=FALSE}
rownames(metadata_final) <- metadata_final$FF_ID

dds <- DESeqDataSetFromMatrix(countData = counts_filt_f[, order(colnames(counts_filt_f))],
                              colData =  metadata_final[order(rownames(metadata_final)), ],
                              design = ~ Group + Age_scaled + Sex)  
dds$Group <- relevel(dds$Group, ref = "Control")
dds_2 <- DESeq(dds)  ## Initial = 17256 genes that passed the filtering criteria

### Extraction of differently expressed genes, comparing samples groups 1 vs 1 --> Tumor x Control, Adjacent x Control, Tumor x Adjacent. 

### Differentially Expressed Genes --> Adjusted p-value < 0.05 & Log2FC > |3| 

### Tumor vs Control
res_ct <- results(dds_2, contrast = c("Group", "Tumor", "Control"))  
res_ct[! is.na(res_ct$padj) & res_ct$padj < 0.05 & abs(res_ct$log2FoldChange) > 3, ]    ### 1646 DEG 
deg_ct <- res_ct[!is.na(res_ct$padj) & res_ct$padj < 0.05 & abs(res_ct$log2FoldChange) > 3, ] 
deg_ct <- as.data.frame(deg_ct)
deg_ct <- round(deg_ct, 5)
#write.csv(deg_ct, "/set/to/working/directory/DEGs_CT.csv")

### Adjacent vs Control
res_ca <- results(dds_2, contrast = c("Group", "Adjacent", "Control"))  
res_ca[!is.na(res_ca$padj) & res_ca$padj < 0.05 & abs(res_ca$log2FoldChange) > 3, ]    ### 396 DEG
deg_ca <- res_ca[!is.na(res_ca$padj) & res_ca$padj < 0.05 & abs(res_ca$log2FoldChange) > 3, ] 
deg_ca <- as.data.frame(deg_ca)
deg_ca <- round(deg_ca, 5) 
#write.csv(deg_ca, "/set/to/working/directory/DEGs_CA.csv")

### Tumor vs Adjacent
res_ta <- results(dds_2, contrast = c("Group", "Tumor", "Adjacent"))  
res_ta[!is.na(res_ta$padj) & res_ta$padj < 0.05 & abs(res_ta$log2FoldChange) > 3, ]    ### 794 DEG
deg_ta <- res_ta[!is.na(res_ta$padj) & res_ta$padj < 0.05 & abs(res_ta$log2FoldChange) > 3, ] 
deg_ta <- as.data.frame(deg_ta)
deg_ta <- round(deg_ta, 5)  
#write.csv(deg_ta, "/set/to/working/directory/DEGs_TA.csv")

```

```{r Number genes after filtering, echo=TRUE}
All_genes <- nrow(dds_2)

table_filtered_DEG <- data.frame(All_genes, nrow(deg_ct), nrow(deg_ca), nrow(deg_ta))
DEG_genes_general <- table_filtered_DEG %>% kable(
    format = "html", 
    caption = "Table 6: Nº of Genes by filtering steps, to define Differential Expressed Genes",
    col.names = c("Nº of Genes - Start of the Analysis", "Sign adj-pval and Log2FC - Tumor vs Control", "Adjacent vs Control", "Tumor vs Adjacent")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

DEG_genes_general
```


### Heatmap

```{r heatmap, echo=TRUE}
# Heatmap - Tumor vs Control
data.clus.tc <- countsTMM[rownames(deg_ct),] #Get normalized data and select the filtered genes 

group.df.tc <- as.data.frame(metadata_final[, colnames(metadata_final) %in% c("Group", "FF_ID")])
rownames(group.df.tc) <- group.df.tc$FF_ID
group.df.tc <- group.df.tc[match(colnames(data.clus.tc), rownames(group.df.tc)), ]

group.df.tc <- group.df.tc[, "Group", drop = FALSE]

#data.clus.tc <- data.clus.tc[, colnames(data.clus.tc) %in% rownames(group.df.tc)]

pheatmap(data.clus.tc, scale = "row", show_rownames = FALSE, cluster_cols = TRUE, clustering_method = "ward.D2", annotation_col = group.df.tc, annotation_colors = list(Group = colors_sam[1:3]), fontsize_row = 2, fontsize_col = 4, main = "Heatmap: Differential Expressed Genes - Tumor vs Control", fontsize = 8)


# Heatmap - Adjacent vs Control
data.clus.ac <- countsTMM[rownames(deg_ca),] #Get normalized data and select the filtered genes 

group.df.ac <- as.data.frame(metadata_final[, colnames(metadata_final) %in% c("Group", "FF_ID")])
rownames(group.df.ac) <- group.df.ac$FF_ID
group.df.ac <- group.df.ac[match(colnames(data.clus.ac), rownames(group.df.ac)), ]

group.df.ac <- group.df.ac[, "Group", drop = FALSE]

pheatmap(data.clus.ac, scale = "row", show_rownames = FALSE, cluster_cols = TRUE, clustering_method = "ward.D2", annotation_col = group.df.ac, annotation_colors = list(Group = colors_sam[1:3]), fontsize_row = 2, fontsize_col = 4, main = "Heatmap: Differential Expressed Genes - Adjacent vs Control", fontsize = 8)



### Heatmap - Adjacent vs Tumor
data.clus.at <- countsTMM[rownames(deg_ta),] #Get normalized data and select the filtered genes 

group.df.at <- as.data.frame(metadata_final[, colnames(metadata_final) %in% c("Group", "FF_ID")])
rownames(group.df.at) <- group.df.at$FF_ID
group.df.at <- group.df.at[match(colnames(data.clus.at), rownames(group.df.at)), ]

group.df.at <- group.df.at[, "Group", drop = FALSE]

pheatmap(data.clus.at, scale = "row", show_rownames = FALSE, cluster_cols = TRUE, clustering_method = "ward.D2", annotation_col = group.df.at, annotation_colors = list(Group = colors_sam[1:3]), fontsize_row = 2, fontsize_col = 4, main = "Heatmap: Differential Expressed Genes - Tumor vs Adjacent", fontsize = 8)

```


## Functional Analysis

The functional analysis is an important part of a study where differential expressed genes are researched and analyzed. It is the step where the genes are associated to their biological pathways and the significance of the study becomes relevant.

### mSigDB and Enrichment

The Molecular Signatures Database [MSigDB] is a resource of thousands of annotated gene sets for use with GSEA, from Human collections. It is used in this study to retrieve the gene ontology groups of the significant genes. In order to work with the `mSigDB` database, the package `msigdbr` from CRAN will be used in R Studio. The Hallmark collection will be extracted with the entrez ID and the HGNC symbol.

Once gene sets were retrieved, the enrichment of the gene sets was done.

```{r msigdb1 ct, echo=TRUE, eval = T, warning= FALSE, message=FALSE}
#Standarizing ENSEMBL gene IDs so that I can get the gene symbols:
rownames(deg_ct) <- gsub("\\..*$", "", rownames(deg_ct))
deg_ct$Symbol <- mapIds(org.Hs.eg.db, keys = rownames(deg_ct), keytype = "ENSEMBL", column = "SYMBOL")
genes.ct <- deg_ct$Symbol

genes_table <- data.frame(Gene = genes.ct)
genes_table_ct <- genes_table[! is.na(genes_table$Gene) , ]

# Hallmark collection
H <- msigdbr(species = "Homo sapiens", category = "H")
H.symbol <- H %>% dplyr::select(gs_name, gene_symbol)

em.ct <- enricher(genes.ct, TERM2GENE=H.symbol)
#em.ct@gene  
#em.ct$ID

cat("The principal Hallmark Gene Sets that have been significantly associated with the Differential Expressed Genes comparing Tumor vs Control are: the", gsub("_", " ", em.ct$ID[1]), ", the", gsub("_", " ", em.ct$ID[2]), ", the", gsub("_", " ", em.ct$ID[3]), ", the", gsub("_", " ", em.ct$ID[4]), ", the", gsub("_", " ", em.ct$ID[5]), ", the", gsub("_", " ", em.ct$ID[6]), "and the", gsub("_", " ", em.ct$ID[7]), ".")

#em.ct[em.ct$ID[1]]$geneID

#The principal Hallmark Gene Sets that have been significantly associated with the Differential Expressed Genes comparing Tumor vs Control are: the HALLMARK EPITHELIAL MESENCHYMAL TRANSITION , the HALLMARK KRAS SIGNALING DN , the HALLMARK G2M CHECKPOINT , the HALLMARK INFLAMMATORY RESPONSE , the HALLMARK COAGULATION , the HALLMARK E2F TARGETS and the HALLMARK KRAS SIGNALING UP .

```


```{r msigdb1 ca, echo=TRUE, eval = T, warning= FALSE, message=FALSE}
#Standarizing ENSEMBL gene IDs so that I can get the gene symbols:
rownames(deg_ca) <- gsub("\\..*$", "", rownames(deg_ca))
deg_ca$Symbol <- mapIds(org.Hs.eg.db, keys = rownames(deg_ca), keytype = "ENSEMBL", column = "SYMBOL")
genes.ca <- deg_ca$Symbol

genes.ca_table <- data.frame(Gene = genes.ca)
genes_table_ca <- genes.ca_table[! is.na(genes.ca_table$Gene) , ]

# Hallmark collection
em.ca <- enricher(genes.ca, TERM2GENE=H.symbol)
#em.ca@gene  
#em.ca$ID

cat("The principal Hallmark Gene Sets that has been significantly associated with the Differential Expressed Genes comparing Adjacent vs Control is the", em.ca$ID[1] , ", and the", em.ca$ID[2], ".")

#The principal Hallmark Gene Sets that has been significantly associated with the Differential Expressed Genes comparing Adjacent vs Control is the HALLMARK_COAGULATION , and the HALLMARK_KRAS_SIGNALING_DN .
```



```{r msigdb1 at, echo=TRUE, eval = T, warning= FALSE, message=FALSE}
#Standarizing ENSEMBL gene IDs so that I can get the gene symbols:
rownames(deg_ta) <- gsub("\\..*$", "", rownames(deg_ta))
deg_ta$Symbol <- mapIds(org.Hs.eg.db, keys = rownames(deg_ta), keytype = "ENSEMBL", column = "SYMBOL")
genes.ta <- deg_ta$Symbol

genes.ta_table <- data.frame(Gene = genes.ta)
genes_table_ta <- genes.ta_table[! is.na(genes.ta_table$Gene) , ]

# Hallmark collection
em.ta <- enricher(genes.ta, TERM2GENE=H.symbol)
#em.ta@gene  
#em.ta$ID

cat("The principal Hallmark Gene Sets that have been significantly associated with the Differential Expressed Genes comparing Adjacent vs Tumor are: the", gsub("_", " ", em.ta$ID[1]), "and the", gsub("_", " ", em.ta$ID[2]), ".")

#The principal Hallmark Gene Sets that have been significantly associated with the Differential Expressed Genes comparing Adjacent vs Tumor are: the HALLMARK KRAS SIGNALING DN and the HALLMARK EPITHELIAL MESENCHYMAL TRANSITION .
```

The main Hallmark gene sets have been identified. Let's see which genes rely on each of them.


```{r msigdb2 gene list all, echo=TRUE, eval = T, warning= FALSE, message=FALSE}
sign.ct =sign(res_ct$log2FoldChange)
logP.ct = -log10(res_ct$pvalue)
metric.ct = logP.ct*sign.ct
geneList.ct = metric.ct
rownames(res_ct) <- gsub("\\..*$", "", rownames(res_ct))
res_ct$Symbol <- mapIds(org.Hs.eg.db, keys = rownames(res_ct), keytype = "ENSEMBL", column = "SYMBOL")
res.ct.df <- as.data.frame(res_ct) # 17256 genes
res.ct.df.filt <- res.ct.df[!duplicated(res.ct.df$Symbol), ]  
res.ct.df.filt <- res.ct.df.filt[! is.na(res.ct.df.filt$Symbol), ] 
rownames(res.ct.df.filt) <- res.ct.df.filt$Symbol
names(geneList.ct) = rownames(res.ct.df.filt)
geneList.ct = sort(geneList.ct, decreasing = TRUE)

genelist.ct.2 <- deg_ct[, sort(deg_ct$lfcSE, decreasing = TRUE)]


sign.ca =sign(res_ca$log2FoldChange)
logP.ca = -log10(res_ca$pvalue)
metric.ca = logP.ca*sign.ca
geneList.ca = metric.ca
rownames(res_ca) <- gsub("\\..*$", "", rownames(res_ca))
res_ca$Symbol <- mapIds(org.Hs.eg.db, keys = rownames(res_ca), keytype = "ENSEMBL", column = "SYMBOL")
res.ca.df <- as.data.frame(res_ca) # 17256 genes
res.ca.df.filt <- res.ca.df[!duplicated(res.ca.df$Symbol), ]  
res.ca.df.filt <- res.ca.df.filt[! is.na(res.ca.df.filt$Symbol), ] 
rownames(res.ca.df.filt) <- res.ca.df.filt$Symbol
names(geneList.ca) = rownames(res.ca.df.filt)
geneList.ca = sort(geneList.ca, decreasing = TRUE)


sign.ta =sign(res_ta$log2FoldChange)
logP.ta = -log10(res_ta$pvalue)
metric.ta = logP.ta*sign.ta
geneList.ta = metric.ta
rownames(res_ta) <- gsub("\\..*$", "", rownames(res_ta))
res_ta$Symbol <- mapIds(org.Hs.eg.db, keys = rownames(res_ta), keytype = "ENSEMBL", column = "SYMBOL")
res.ta.df <- as.data.frame(res_ta) # 17256 genes
res.ta.df.filt <- res.ta.df[!duplicated(res.ta.df$Symbol), ]  
res.ta.df.filt <- res.ta.df.filt[! is.na(res.ta.df.filt$Symbol), ] 
rownames(res.ta.df.filt) <- res.ta.df.filt$Symbol
names(geneList.ta) = rownames(res.ta.df.filt)
geneList.ta = sort(geneList.ta, decreasing = TRUE)

```


```{r msigdb2 all , echo=TRUE, eval = T, warning= FALSE, message=FALSE}
barplot(em.ct) + ggtitle("Hallmark Gene Sets - Tumor vs Control") + theme(axis.text.y = element_text(size = 10)) + xlab ("Gene count")

barplot(em.ta) + ggtitle("Hallmark Gene Sets - Tumor vs Adjacent") + theme(axis.text.y = element_text(size = 10)) + xlab ("Gene count")

barplot(em.ca) + ggtitle("Hallmark Gene Sets - Adjacent vs Control") + theme(axis.text.y = element_text(size = 10)) + xlab ("Gene count")
```


```{r}
em.ct.df <- data.frame(GS = em.ct$ID, GR = em.ct$GeneRatio, Gene = em.ct$geneID)
write.csv(em.ct.df, "/set/to/working/directory/Hgenes_CT.csv")

em.ca.df <- data.frame(GS = em.ca$ID, GR = em.ca$GeneRatio, Gene = em.ca$geneID)
write.csv(em.ca.df, "/set/to/working/directory/Hgenes_CA.csv")

em.ta.df <- data.frame(GS = em.ta$ID, GR = em.ta$GeneRatio, Gene = em.ta$geneID)
write.csv(em.ta.df, "/set/to/working/directory/Hgenes_TA.csv")
```


```{r}
hallmark_count_ct <- (em.ct@result[em.ct@result$p.adjust < 0.05, ])[, colnames(em.ct@result) %in% c("FoldEnrichment", "Count", "GeneRatio", "geneID")]
# write.csv(hallmark_count_ct, "/set/to/working/directory/hallmark_count_CvsT.csv")

hallmark_count_ta <- (em.ta@result[em.ta@result$p.adjust < 0.05, ])[, colnames(em.ta@result) %in% c("FoldEnrichment", "Count", "GeneRatio", "geneID")]
# write.csv(hallmark_count_ta, "/set/to/working/directory/hallmark_count_AvsT.csv")

hallmark_count_ca <- (em.ca@result[em.ca@result$p.adjust < 0.05, ])[, colnames(em.ca@result) %in% c("FoldEnrichment", "Count", "GeneRatio", "geneID")]
# write.csv(hallmark_count_ca, "/set/to/working/directory/hallmark_count_CvsA.csv")
```



```{r msigdb3, echo=T, eval = T, warning=FALSE, message = FALSE}

clusterProfiler::dotplot(em.ct)  + ggtitle("Hallmark Gene Sets - Control vs Tumor") + theme(axis.text.y = element_text(size = 10)) + xlab ("Gene ratio")

clusterProfiler::dotplot(em.ta)  + ggtitle("Hallmark Gene Sets - Adjacent vs Tumor") + theme(axis.text.y = element_text(size = 10)) + xlab ("Gene count")

clusterProfiler::dotplot(em.ca)  + ggtitle("Hallmark Gene Sets - Control vs Adjacent") + theme(axis.text.y = element_text(size = 10)) + xlab ("Gene count")

```


```{r msigdb4, echo=T, eval = T, warning=FALSE, message = FALSE}

cnetplot(em.ct, showCategory = 10, showGenes = 10, categorySize = "p.adjust" , size_category = 1, size_edge=1, size_item = 1, cex_label_gene = 5, cex_label_category=0.3, foldChange=geneList.ct) + ggtitle("DEGs involved in Hallmark Gene Sets - Tumor vs Control") + theme (plot.title = element_text(hjust = 0.1), plot.subtitle = element_text(hjust = 0.067)) 

cnetplot(em.ca, showCategory = 17, size_category = 1, size_edge=0.1, size_item = 1, cex_label_gene=10, cex_label_category=0.3, foldChange= geneList.ca) + ggtitle("DEGs involved in Hallmark Gene Sets - Adjacent vs Control")  # Gene-concept plot: network of genes and gene sets


cnetplot(em.ta, showCategory = 17, size_category = 1, size_edge=0.1, size_item = 1, cex_label_gene=0.01, cex_label_category=0.3, foldChange= geneList.ta) + ggtitle("DEGs involved in Hallmark Gene Sets - Tumor vs Adjacent")  

```


```{r msigdb5, eval = T, warning=FALSE, message = FALSE}

heatplot(em.ct, label_format = 0.01, foldChange = geneList.ct) + theme(axis.text.x = element_text(size = 3, angle = 90, hjust = 1)) + ggtitle("DEGs involved in Hallmark Gene Sets - Tumor vs Control") 


heatplot(em.ca, label_format = 0.01, foldChange = geneList.ca) + theme(axis.text.x = element_text(size = 6.5, angle = 90, hjust = 1)) + ggtitle("DEGs involved in Hallmark Gene Sets - Adjacent vs Control") # Heat map, genes in gene sets


heatplot(em.ta, label_format = 0.01, foldChange = geneList.ta) + theme(axis.text.x = element_text(size = 6.5, angle = 90, hjust = 1)) + ggtitle("DEGs involved in Hallmark Gene Sets - Tumor vs Adjacent") # Heat map, genes in gene sets
```



### GSVA method

The `GSVA` package from BioConductor performs the evaluation of gene set enrichment for each sample of an experiment. It firsts computes the parameters with the `gsvaParam()` function, and then applies the `gsva()` function.

```{r GSVA, echo=TRUE, message=FALSE}

metadata_final[order(rownames(metadata_final)), ]
count_gn <- counts_filt_f

rownames(count_gn) <- gsub("\\..*$", "", rownames(count_gn))
Symbol <- mapIds(org.Hs.eg.db, keys = rownames(count_gn), keytype = "ENSEMBL", column = "SYMBOL")
genenames.df <- as.data.frame(count_gn) # 17256 genes

Symbol.2 <- Symbol[!duplicated(Symbol)] # 13476 genes
Symbol.2 <- Symbol.2[!is.na(Symbol.2)] # 13475 genes

Symbol.2 <- as.data.frame(Symbol.2)

count_gn.2 <- merge(count_gn, Symbol.2, by= "row.names", all.x = FALSE)
rownames(count_gn.2) <- count_gn.2$Symbol.2
count_gn.2 <- count_gn.2 [, !colnames(count_gn.2) %in% c("Row.names", "Symbol.2")]

gsH_list <- lapply(unique(H.symbol$gs_name), function(set_name) {
    genes <- unique(H.symbol$gene_symbol[H.symbol$gs_name == set_name])
    GeneSet(setName = set_name, geneIds = genes)
})

gsH <- GeneSetCollection(gsH_list)

gsvaPar <- gsvaParam(as.matrix(count_gn.2), gsH)

gsva <- gsva(gsvaPar, verbose=FALSE)
gsva <- gsva[, order(colnames(gsva))]

annotation_col <- data.frame(Group = metadata_final[order(rownames(metadata_final)), ]$Group)
rownames(annotation_col) <- rownames(metadata_final[order(rownames(metadata_final)), ])
annotation_colors = list(Group = colors_sam[1:3])

identical(rownames(metadata_final[order(rownames(metadata_final)), ]), colnames(gsva)) ### TRUE

pheatmap(gsva, cluster_cols = TRUE, cluster_rows = TRUE, clustering_method = "ward.D2",
          scale="row", cellheight = 4.5, fontsize_col = 3.5, fontsize_row = 4, 
         annotation_col = annotation_col, annotation_colors = annotation_colors)


group_order <- order(metadata_final[order(rownames(metadata_final)), ]$Group)
gsva_ordered <- gsva[, group_order]
ann_col_ordered <- annotation_col[group_order, , drop= FALSE]

pheatmap(gsva_ordered, cluster_cols = FALSE, cluster_rows = TRUE, clustering_method = "ward.D2",
          scale="row", cellheight = 6, fontsize_col = 3.5, fontsize_row = 5, 
         annotation_col = ann_col_ordered, annotation_colors = annotation_colors)
```




## Deconvolution

Tumor deconvolution enables the identification of diverse cell types that comprise solid tumors. Understanding the interactions between the tumor cells and surrounding non-malignant cells, including stromal, endothelial, and immune cells, is essential to model the mechanisms underlying tumor survival and spreading.2 In particular, identifying the degree and nature of immune cell and other microenvironmental infiltration can assist in predicting a tumor responsiveness to specific immunotherapeutic regimens. Algorithmic tumor deconvolution is based upon the knowledge that specific genes are expressed at distinct levels within specific cell types. (doi: https://doi.org/10.1016/j.crmeth.2024.100708).  

MCP-counter = Microenvironment Cell Populations-counter.  It provides tumor deconvolution predictions from bulk RNA-seq data. 

### Tumor Samples

```{r deconvolution and tumor purity - tumor, echo=FALSE, cache=TRUE}
### DECONVOLUTION

### Deconvolution for each group of samples:
meta_control <- metadata_final[metadata_final$Group == "Control", ]  # 32
meta_adj <- metadata_final[metadata_final$Group == "Adjacent", ]  # 39 
meta_tumor <- metadata_final[metadata_final$Group == "Tumor", ]  # 53

##### Getting the Normalized gene dataset for each of the groups

## Tumor:
deconv_tumor <- counts_filt_f[, colnames(counts_filt_f) %in% meta_tumor$FF_ID]
rownames(deconv_tumor) <- gsub("\\..*$", "", rownames(deconv_tumor))
deconv_tumor$Symbol <- mapIds(org.Hs.eg.db, keys = rownames(deconv_tumor), keytype = "ENSEMBL", column = "SYMBOL")
genes.tumor <- deconv_tumor$Symbol
length(genes.tumor) #17256
length(unique(genes.tumor))  # 13476
deconv_tumor <- deconv_tumor[!duplicated(deconv_tumor$Symbol), ]  #13476 genes
deconv_tumor <- deconv_tumor[! is.na(deconv_tumor$Symbol), ]
rownames(deconv_tumor) <- deconv_tumor$Symbol
deconv_tumor <- deconv_tumor[, ! colnames(deconv_tumor) %in% c("Symbol")]

# Normalization
deconv_tumor_norm <- DGEList(deconv_tumor)   ### 13542 genes and 53 samples ### 
keep_dt <- rowSums(cpm(deconv_tumor_norm)>0)>=1
deconv_tumor_norm <- deconv_tumor_norm[keep_dt, , keep.lib.sizes=FALSE] # 13542 genes
deconv_tumor_norm <- calcNormFactors(deconv_tumor_norm,"TMM")
deconv_tum_normcounts <- deconv_tumor_norm$counts

# PCA
t_deconv_tumor_norm <- as.data.frame(t(deconv_tum_normcounts))

### Deconvolution
tum_res_quantiseq <- deconvolute(deconv_tum_normcounts, "quantiseq", tumor = TRUE)
tum_res_mcp_counter <- deconvolute(deconv_tum_normcounts, "mcp_counter")
tum_res_estimate <- deconvolute(deconv_tum_normcounts, "estimate")

tumorPur_tum <- data.frame(perc=t(tum_res_estimate[4,-1]))
unkCells_tum <- data.frame(perc=t(tum_res_quantiseq[11,-1]))

tumPur_tum <- cbind.data.frame(tumorPur_tum, unkCells_tum)
names(tumPur_tum) <- c("Tumor_Purity", "Uncharacterized_Cells")

cor.test_tum_pur <- cor.test(tumorPur_tum$perc, unkCells_tum$perc, method="spearman")
### Rho = 0.8146
### p-val = 2.2e-16

plot(tumorPur_tum$perc, unkCells_tum$perc, pch =20, xlab = "Tumor purity (estimate)", ylab = "Uncharacterized cells (quantiseq)", main = "Tumor purity vs Uncharacterized cells", text(0.60, 0.748, cex = 0.83, labels = paste0("Spearman's Rho = ", round(cor.test_tum_pur$estimate, 4), "\n p-val = 2.2e-16"))) 

ggscatter(tumPur_tum, x= "Tumor_Purity", y= "Uncharacterized_Cells", add = "reg.line", conf.int = TRUE, cor.coef = TRUE, cor.method = "spearman", xlab = "Tumor purity (estimate)", ylab = "Uncharacterized cells (quantiseq)", main = "Tumor Purity vs Uncharacterized cells (Spearman's correlation)", size = 1.5)

Uncharacterized_cells <- tum_res_quantiseq %>%
  gather(sample, fraction, -cell_type) %>%
  # plot as stacked bar chart
  ggplot(aes(x = sample, y = fraction, fill = cell_type)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_fill_brewer(palette = "Paired") +
  scale_x_discrete(limits = rev(levels(tum_res_quantiseq))) +
  theme (axis.text.y = element_text(size = 5)) +
  xlab ("Tumor Samples") + ylab ("Fraction")
plot(Uncharacterized_cells)

mcp_counter_tum <- as.data.frame(tum_res_mcp_counter[, -1])
row.names(mcp_counter_tum) <- tum_res_mcp_counter$cell_type

t_deconv_tumor_norm$tumPur <- tumorPur_tum$perc

estScaled_tum_pur <- as.data.frame(t(scale(t(mcp_counter_tum), center = T, scale = T)))
pal <- colorRampPalette(c("blue", "white", "red"))(264)

dd_tumpurity <- dist(t(estScaled_tum_pur), method = "euclidean")
hc_tumpurity <- hclust(dd_tumpurity, method = "complete")
group_tumpurity <- data.frame(deconv=cutree(hc_tumpurity, k=2))
setCol = data.frame(col=brewer.pal(8, "Set2")[1:2], k=c(1,2))

colgroup_tumpurity <- setCol$col[match(group_tumpurity$deconv, setCol$k)]


rownames(estScaled_tum_pur) <- ifelse((rownames(estScaled_tum_pur) == "Cancer associated fibroblast"), "CAF", rownames(estScaled_tum_pur))
rownames(estScaled_tum_pur) <- gsub("/", "/\n", rownames(estScaled_tum_pur))
rownames(estScaled_tum_pur) <- ifelse((rownames(estScaled_tum_pur) == "Myeloid /\ndendritic cell"), "Myeloid \ndendritic cell", rownames(estScaled_tum_pur))
rownames(estScaled_tum_pur) <- ifelse((rownames(estScaled_tum_pur) == "cytotoxicity score"), "Cytotoxicity \nScore", rownames(estScaled_tum_pur))
rownames(estScaled_tum_pur) <- ifelse((rownames(estScaled_tum_pur) == "Myeloid dendritic cell"), "Myeloid \ndendritic cell", rownames(estScaled_tum_pur))


median(as.numeric(tum_res_quantiseq[tum_res_quantiseq$cell_type == "uncharacterized cell",-1])) ## 0.6082
mean(as.numeric(tum_res_quantiseq[tum_res_quantiseq$cell_type == "uncharacterized cell",-1])) ## 0.5934

```


### Adjacent Samples

```{r deconvolution and tumor purity - adjacent, echo=FALSE, cache=TRUE}
### DECONVOLUTION

## Adjacent:
deconv_adj <- counts_filt_f[, colnames(counts_filt_f) %in% meta_adj$FF_ID]
rownames(deconv_adj) <- gsub("\\..*$", "", rownames(deconv_adj))
deconv_adj$Symbol <- mapIds(org.Hs.eg.db, keys = rownames(deconv_adj), keytype = "ENSEMBL", column = "SYMBOL")
genes.adj <- deconv_adj$Symbol
length(genes.adj) #17256
length(unique(genes.adj))  # 13543
deconv_adj <- deconv_adj[!duplicated(deconv_adj$Symbol), ]  #13543 genes
deconv_adj <- deconv_adj[! is.na(deconv_adj$Symbol), ]
rownames(deconv_adj) <- deconv_adj$Symbol
deconv_adj <- deconv_adj[, ! colnames(deconv_adj) %in% c("Symbol")]

# Normalization
deconv_adj_norm <- DGEList(deconv_adj)   ### 13542 genes and 39 samples ### 
keep_da <- rowSums(cpm(deconv_adj_norm)>0)>=1
deconv_adj_norm <- deconv_adj_norm[keep_da, , keep.lib.sizes=FALSE] # 13542 genes
deconv_adj_norm <- calcNormFactors(deconv_adj_norm,"TMM")
deconv_adj_normcounts <- deconv_adj_norm$counts

t_deconv_adj_norm <- as.data.frame(t(deconv_adj_normcounts))

### Deconvolution
adj_res_quantiseq <- deconvolute(deconv_adj_normcounts, "quantiseq", tumor = TRUE)
adj_res_mcp_counter <- deconvolute(deconv_adj_normcounts, "mcp_counter")
adj_res_estimate <- deconvolute(deconv_adj_normcounts, "estimate")

tumorPur_adj <- data.frame(perc=t(adj_res_estimate[4,-1]))
unkCells_adj <- data.frame(perc=t(adj_res_quantiseq[11,-1]))

tumPur_adj <- cbind.data.frame(tumorPur_adj, unkCells_adj)
names(tumPur_adj) <- c("Tumor_Purity", "Uncharacterized_Cells")

cor.test_adj_pur <- cor.test(tumorPur_adj$perc, unkCells_adj$perc, method="spearman")
### Rho = 0.5417004 
### p-val = 0.00047


plot(tumorPur_adj$perc, unkCells_adj$perc, pch =20, xlab = "Tumor purity (estimate)", ylab = "Uncharacterized cells (quantiseq)", main = "Tumor purity vs Uncharacterized cells - Adjacent samples", text(0.60, 0.748, cex = 0.83, labels = paste0("Spearman's Rho =",  round(cor.test_adj_pur$estimate, 3), "\np-val=", round(cor.test_adj_pur$p.value, 5)))) 

ggscatter(tumPur_adj, x= "Tumor_Purity", y= "Uncharacterized_Cells", add = "reg.line", conf.int = TRUE, cor.coef = TRUE, cor.method = "spearman", xlab = "Tumor purity (estimate) - Adjacent samples", ylab = "Uncharacterized cells (quantiseq)", main = "Tumor Purity vs Uncharacterized cells (Spearman's correlation)", size = 1.5)

Uncharacterized_cells_adjacent <- adj_res_quantiseq %>%
  gather(sample, fraction, -cell_type) %>%
  # plot as stacked bar chart
  ggplot(aes(x = sample, y = fraction, fill = cell_type)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_fill_brewer(palette = "Paired") +
  scale_x_discrete(limits = rev(levels(adj_res_quantiseq))) +
  theme (axis.text.y = element_text(size = 6)) +
  xlab ("Adjacent Samples") + ylab ("Fraction")
plot(Uncharacterized_cells_adjacent)


mcp_counter_adj <- as.data.frame(adj_res_mcp_counter[, -1])
row.names(mcp_counter_adj) <- adj_res_mcp_counter$cell_type

t_deconv_adj_norm$tumPur <- tumorPur_adj$perc

median(as.numeric(adj_res_quantiseq[adj_res_quantiseq$cell_type == "uncharacterized cell",-1])) ## 0.66608
mean(as.numeric(adj_res_quantiseq[adj_res_quantiseq$cell_type == "uncharacterized cell",-1])) ## 0.58224
 
```




### Control Samples

```{r deconvolution and tumor purity - control, echo=FALSE, cache=TRUE}
### DECONVOLUTION

## Control:
deconv_ctrl <- counts_filt_f[, colnames(counts_filt_f) %in% meta_control$FF_ID]
rownames(deconv_ctrl) <- gsub("\\..*$", "", rownames(deconv_ctrl))
deconv_ctrl$Symbol <- mapIds(org.Hs.eg.db, keys = rownames(deconv_ctrl), keytype = "ENSEMBL", column = "SYMBOL")
genes.ctrl <- deconv_ctrl$Symbol
length(genes.ctrl) #17256
length(unique(genes.ctrl))  # 13543
deconv_ctrl <- deconv_ctrl[!duplicated(deconv_ctrl$Symbol), ]  #13543 genes
deconv_ctrl <- deconv_ctrl[! is.na(deconv_ctrl$Symbol), ]
rownames(deconv_ctrl) <- deconv_ctrl$Symbol
deconv_ctrl <- deconv_ctrl[, ! colnames(deconv_ctrl) %in% c("Symbol")]

# Normalization
deconv_ctrl_norm <- DGEList(deconv_ctrl)   ### 13542 genes and 39 samples ### 
keep_dc <- rowSums(cpm(deconv_ctrl_norm)>0)>=1
deconv_ctrl_norm <- deconv_ctrl_norm[keep_dc, , keep.lib.sizes=FALSE] # 13542 genes
deconv_ctrl_norm <- calcNormFactors(deconv_ctrl_norm,"TMM")
deconv_ctrl_normcounts <- deconv_ctrl_norm$counts

t_deconv_ctrl_norm <- as.data.frame(t(deconv_ctrl_normcounts))

### Deconvolution
ctrl_res_quantiseq <- deconvolute(deconv_ctrl_normcounts, "quantiseq", tumor = TRUE)
ctrl_res_mcp_counter <- deconvolute(deconv_ctrl_normcounts, "mcp_counter")
ctrl_res_estimate <- deconvolute(deconv_ctrl_normcounts, "estimate")

tumorPur_ctrl <- data.frame(perc=t(ctrl_res_estimate[4,-1]))
unkCells_ctrl <- data.frame(perc=t(ctrl_res_quantiseq[11,-1]))

tumPur_ctrl <- cbind.data.frame(tumorPur_ctrl, unkCells_ctrl)
names(tumPur_ctrl) <- c("Tumor_Purity", "Uncharacterized_Cells")

cor.test_ctrl_pur <- cor.test(tumorPur_ctrl$perc, unkCells_ctrl$perc, method="spearman")
### Rho = 0.3214 
### p-val = 0.07323 


plot(tumorPur_ctrl$perc, unkCells_ctrl$perc, pch =20, xlab = "Tumor purity (estimate)", ylab = "Uncharacterized cells (quantiseq)", main = "Tumor purity vs Uncharacterized cells - Control samples", text(0.60, 0.748, cex = 0.83, labels = paste0("Spearman's Rho =",  round(cor.test_ctrl_pur$estimate, 3), "\np-val=", round(cor.test_ctrl_pur$p.value, 5)))) 

ggscatter(tumPur_ctrl, x= "Tumor_Purity", y= "Uncharacterized_Cells", add = "reg.line", conf.int = TRUE, cor.coef = TRUE, cor.method = "spearman", xlab = "Tumor purity (estimate) - Control samples", ylab = "Uncharacterized cells (quantiseq)", main = "Tumor Purity vs Uncharacterized cells (Spearman's correlation)", size = 1.5)

Uncharacterized_cells_control <- ctrl_res_quantiseq %>%
  gather(sample, fraction, -cell_type) %>%
  # plot as stacked bar chart
  ggplot(aes(x = sample, y = fraction, fill = cell_type)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_fill_brewer(palette = "Paired") +
  scale_x_discrete(limits = rev(levels(ctrl_res_quantiseq))) +
  theme (axis.text.y = element_text(size = 6)) +
  xlab ("Control Samples") + ylab ("Fraction")
plot(Uncharacterized_cells_control)

mcp_counter_ctrl <- as.data.frame(ctrl_res_mcp_counter[, -1])
row.names(mcp_counter_ctrl) <- ctrl_res_mcp_counter$cell_type

t_deconv_ctrl_norm$tumPur <- tumorPur_ctrl$perc

estScaled_ctrl_pur <- as.data.frame(t(scale(t(mcp_counter_ctrl), center = T, scale = T)))
dd_ctrlpurity <- dist(t(estScaled_ctrl_pur), method = "euclidean")
hc_ctrlpurity <- hclust(dd_ctrlpurity, method = "complete")
group_ctrlpurity <- data.frame(deconv=cutree(hc_ctrlpurity, k=2))
setCol = data.frame(col=brewer.pal(8, "Set2")[1:2], k=c(1,2))

colgroup_ctrlpurity <- setCol$col[match(group_ctrlpurity$deconv, setCol$k)]

```


Tumor purity vs Uncharacterized cells correlation test (Spearman's) no significant in Control samples --> It makes sense since the infiltrations are not related to tumoral tissue. 


## PC Subtypes Signature

Subtypes of pancreatic ductal adenocarcinoma and their differing responses to therapy. 


```{r preparing only tumors, echo=FALSE, cache=TRUE}

### Preparing only tumor samples

tumors <- metadata_final[metadata_final$Group == "Tumor", ] ## 53 samples
  
raw_tumor_counts <- counts_filt_f[, colnames(counts_filt_f) %in% tumors$FF_ID] #raw tumor counts  --> 17256 genes

### Gene names symbols in the tumors data:
#Standarizing ENSEMBL gene IDs so that I can get the gene symbols:
tumor_counts <- raw_tumor_counts
rownames(tumor_counts) <- gsub("\\..*$", "", rownames(tumor_counts))
tumor_counts$Symbol <- mapIds(org.Hs.eg.db, keys = rownames(tumor_counts), keytype = "ENSEMBL", column = "SYMBOL")
genes.tumor <- tumor_counts$Symbol
# length(genes.tumor) #17256
# length(unique(genes.tumor))  # 13542 genes
tumor_counts <- tumor_counts[!duplicated(tumor_counts$Symbol), ]  #13542 genes
tumor_counts <- tumor_counts[! is.na(tumor_counts$Symbol), ]
rownames(tumor_counts) <- tumor_counts$Symbol

tumor_counts <- tumor_counts[, ! colnames(tumor_counts) %in% c("Symbol")]  # 13542 genes --> Gene symbol 
```

```{r Normalizing tumor data for signature, echo=FALSE, cache=TRUE}

# Normalization
tum_counts_n <- DGEList(tumor_counts)   ### 13542 genes and 53 samples ### 
keep1 <- rowSums(cpm(tum_counts_n)>0)>=1
tum_counts_n <- tum_counts_n[keep1, , keep.lib.sizes=FALSE] # 13475 genes
tum_counts_f <- calcNormFactors(tum_counts_n,"TMM")

# recomputing cpm after filtering genes
norm_counts <- cpm(tum_counts_f, log = T, normalized.lib.sizes=FALSE)  ### converted to cpm (counts per million) and log2 transformed 
norm_counts <- as.data.frame(norm_counts)
normal_counts <- norm_counts[, order(names(norm_counts)),]

# now pca with cpm normalization on all genes!
normal_counts <- as.matrix(normal_counts)


pcaCounts <- prcomp(as.data.frame(t(normal_counts)), center = T, scale. = T)
autoplot(pcaCounts, data=tumors, colour="Group", shape = "Sex") + ggtitle("Principal Component Analysis ")  + scale_colour_manual(values= colors_sam) + theme_minimal() + stat_ellipse(aes(group = Group, color=Group), level = 0.95, alpha = 0.4)
### PC1 = 17.98%
### PC2 = 13.51% 

# tumor_counts_m <- as.matrix(tumor_counts)
# pcaCounts_tum <- prcomp(as.data.frame(t(tumor_counts_m)), center = T, scale. = T)
# autoplot(pcaCounts_tum, data=tumors, colour="Group", shape = "Sex") + ggtitle("Principal Component Analysis ")  + scale_colour_manual(values= colors_sam) + theme_minimal() + stat_ellipse(aes(group = Group, color=Group), level = 0.95, alpha = 0.4)

### 24.63%
### 12.17%

```


### Bailey

In 2016, Bailey et al. performed an mRNA hybridization analysis of 266 patients with nontreated bulk resected, primary PDAC covering the full range of cellularity. 
RNAseq was performed on a subset of 96 samples selected on the basis of high epithelial content. 
Bailey et al. defined four subtypes (validated in the extended set of 266 mRNA arrayed cases), which they termed Squamous, Pancreatic Progenitor, Immunogenic and Aberrantly Differentiated Endocrine Exocrine (ADEX).


Genomic analyses identify molecular subtypes of pancreatic cancer (doi: https://doi.org/10.1038/nature16965). 

Here we performed a comprehensive integrated genomic analysis of 456 PCs and their histopathological variants using a combination of whole-genome and deep-exome sequencing, with gene copy number analysis to determine the mutational mechanisms and candidate genomic events important in pancreatic carcinogenesis. RNA expression profiles were used to define four subtypes and the different transcriptional networks that underpin them. These subtypes are associated with distinct histopathological characteristics and differential survival.

Subtypes: (1) squamous; (2) pancreatic progenitor; (3) immunogenic; and (4) aberrantly differentiated endocrine exocrine (ADEX) on the basis of the differential expression of transcription factors and downstream targets important in lineage specification and differentiation during pancreas development and regeneration.

POSITIVE IMPACT OF THE SIGNATURE:
A predominant advantage of PDAC subtyping is related to Precision Medicine. Molecular subtyping provides information that can substantially impact the selection of treatments for this disease particularly at specific stages.


```{r building Bailey's signature, echo=TRUE}
gp1 <- readxl::read_xlsx("/set/to/working/directory/41586_2016_BFnature16965_MOESM273_ESM.xlsx", sheet = 1)
gp1 <- gp1$Nodes
genes_gp1 <- unique(unlist(lapply(gp1, function(x) unlist(strsplit(x, split=",")))))

gp10 <- readxl::read_xlsx("/set/to/working/directory/41586_2016_BFnature16965_MOESM273_ESM.xlsx", sheet = 2)
gp10 <- gp10$Nodes
genes_gp10 <- unique(unlist(lapply(gp10, function(x) unlist(strsplit(x, split=",")))))

gp2 <- readxl::read_xlsx("/set/to/working/directory/41586_2016_BFnature16965_MOESM273_ESM.xlsx", sheet = 3)
gp2<- gp2$Nodes
genes_gp2 <- unique(unlist(lapply(gp2, function(x) unlist(strsplit(x, split=",")))))

gp3 <- readxl::read_xlsx("/set/to/working/directory/41586_2016_BFnature16965_MOESM273_ESM.xlsx", sheet = 4)
gp3<- gp3$Nodes
genes_gp3 <- unique(unlist(lapply(gp3, function(x) unlist(strsplit(x, split=",")))))

gp4 <- readxl::read_xlsx("/set/to/working/directory/41586_2016_BFnature16965_MOESM273_ESM.xlsx", sheet = 5)
gp4<- gp4$Nodes
genes_gp4 <- unique(unlist(lapply(gp4, function(x) unlist(strsplit(x, split=",")))))

gp5 <- readxl::read_xlsx("/set/to/working/directory/41586_2016_BFnature16965_MOESM273_ESM.xlsx", sheet = 6)
gp5<- gp5$Nodes
genes_gp5 <- unique(unlist(lapply(gp5, function(x) unlist(strsplit(x, split=",")))))

gp6 <- readxl::read_xlsx("/set/to/working/directory/41586_2016_BFnature16965_MOESM273_ESM.xlsx", sheet = 7)
gp6<- gp6$Nodes
genes_gp6 <- unique(unlist(lapply(gp6, function(x) unlist(strsplit(x, split=",")))))

gp7 <- readxl::read_xlsx("/set/to/working/directory/41586_2016_BFnature16965_MOESM273_ESM.xlsx", sheet = 8)
gp7<- gp7$Nodes
genes_gp7 <- unique(unlist(lapply(gp7, function(x) unlist(strsplit(x, split=",")))))

gp8 <- readxl::read_xlsx("/set/to/working/directory/41586_2016_BFnature16965_MOESM273_ESM.xlsx", sheet = 9)
gp8<- gp8$Nodes
genes_gp8 <- unique(unlist(lapply(gp8, function(x) unlist(strsplit(x, split=",")))))

gp9 <- readxl::read_xlsx("/set/to/working/directory/41586_2016_BFnature16965_MOESM273_ESM.xlsx", sheet = 10)
gp9<- gp9$Nodes
genes_gp9 <- unique(unlist(lapply(gp9, function(x) unlist(strsplit(x, split=",")))))


adex <- unique(c(genes_gp9, genes_gp10))
squamous <- unique(c(genes_gp2, genes_gp3, genes_gp4, genes_gp5))
progenitor <- genes_gp1
immunogenic <- unique(c(genes_gp6, genes_gp7, genes_gp8))

Baileysig <- data.frame(gene=c(squamous, adex, progenitor, immunogenic), 
                     group=c(rep("squamous", length(squamous)), rep("adex", length(adex)), rep("progenitor", length(progenitor)), rep("immunogenic", length(immunogenic))),
                     color=c(rep("steelblue", length(squamous)), rep("saddlebrown", length(adex)), rep("orange", length(progenitor)), rep("red3", length(immunogenic))))


### Bailey sig = 1615 genes  
dim(Baileysig)
Baileysig$group <- as.factor(Baileysig$group)
# levels(Baileysig$group)  # "adex"  "immunogenic" "progenitor"  "squamous"  

length(Baileysig$gene[Baileysig$group == "adex"]) #78 genes related to the adex subtype
length(Baileysig$gene[Baileysig$group == "immunogenic"])  #215 genes related to the immunogenic subtype
length(Baileysig$gene[Baileysig$group == "progenitor"]) #397 genes related to the progenitor subtype
length(Baileysig$gene[Baileysig$group == "squamous"])  #925 genes related to the squamous subtype


Baileysig

#write.csv(Baileysig, "/set/to/working/directory/Bailey_signature.csv")

```


```{r bailey , echo= FALSE, cache=TRUE}

## Loading annotation file:
annot <- read.table("/set/to/working/directory/gencode.v26.GRCh38.ERCC.genes.info.txt", header = TRUE, stringsAsFactors = FALSE)   #56,292 genes in the annotation file 
### Annotation file: downloaded on Jul 27, 2020

annot2 <- annot[annot$gene_type == "protein_coding", ] #19,291 protein coding genes
ids_protcoding <- annot2$gene_name[(row.names(normal_counts) %in% annot2$gene_name)]

# subsample with Bailey signature genes
ids_bailey <- ids_protcoding[ids_protcoding%in%Baileysig$gene] #1314 genes 

bailey_expr <- normal_counts[rownames(normal_counts) %in% ids_protcoding, ] #9078 genes
trans_bailey_expr <- as.data.frame(t(bailey_expr))
pca_bailey <- prcomp(trans_bailey_expr, center = T, scale=TRUE)
autoplot(pca_bailey, data=tumors, colour="Group", shape = "Sex") + ggtitle("Principal Component Analysis ")  + scale_colour_manual(values= colors_sam) + theme_minimal() + stat_ellipse(aes(group = Group, color=Group), level = 0.95, alpha = 0.4)
### PC1 = 19.2%
### PC2 = 14.68%

row.names(bailey_expr) 
B_sign <- Baileysig[Baileysig$gene%in%row.names(bailey_expr), ]  #1154 genes

# PDA signature heatmap
pal <- colorRampPalette(c("blue", "white", "red"))(264)
# scaling+centering bailey's gene expression
Bai_genes <- bailey_expr[rownames(bailey_expr) %in% B_sign$gene, ]  #1154   53
Bai_scaled <- as.data.frame(t(apply(Bai_genes, 1, scale)))
colnames(Bai_scaled) <- colnames(Bai_genes)

Bai_scaled$Group <- B_sign$group[match(rownames(Bai_scaled), B_sign$gene)]
Bai_scaled <- Bai_scaled[order(Bai_scaled$Group), ]

hm_cols_bailey <- colors_bailey[match(Bai_scaled$Group, tolower(names(colors_bailey)))]




heatmap.2(as.matrix(Bai_scaled[, -ncol(Bai_scaled)]), main = "Bailey's signature expression patterns", density.info = "none", trace = "none", dendrogram = "col", col = pal, Rowv=F, RowSideColors=hm_cols_bailey, na.rm=TRUE, cexRow = 0.02, xlab = "Tumor Samples", ylab = "Genes")
legend("left", legend = unique(names(hm_cols_bailey)), fill = unique((hm_cols_bailey)), border = "black", title = "PC Subtypes", cex = 0.7, box.lwd = 0.7)



### Assigning the Bailey's PDAC subtypes to the samples
Bai_subtypes <- list(
  Progenitor = Baileysig$gene[Baileysig$group == "progenitor"],
  Squamous = Baileysig$gene[Baileysig$group == "squamous"],
  Immunogenic = Baileysig$gene[Baileysig$group == "immunogenic"],
  ADEX = Baileysig$gene[Baileysig$group == "adex"])


subtypes_Zscores <- sapply(Bai_subtypes, function(genes) {
  common_genes <- intersect(genes, rownames(Bai_scaled))   # Keep only genes that exist in your expression matrix
  colMeans(Bai_scaled[common_genes, -ncol(Bai_scaled) , drop = FALSE])})   # Compute the column means (average expression) for those genes

subtypes_Zscores <- as.data.frame(subtypes_Zscores)

subtypes_Zscores$PredBailey <- colnames(subtypes_Zscores)[apply(subtypes_Zscores, 1, which.max)]

table(subtypes_Zscores$PredBailey)      #    ADEX Immunogenic  Progenitor    Squamous 
                                        #      12          12          16          13

subtypes_Zscores

#write.csv(subtypes_Zscores, "/set/to/working/directory/Prediction_Bailey.csv")
```


Prediction of the PDAC subtypes based on the Bailey's signature and the gene expression Z scores of each of the samples. 

```{r bailey hc, echo= FALSE, cache=TRUE}
subtypes_Zscores$Samples_ID <- rownames(subtypes_Zscores)
pred_subtypes <- subtypes_Zscores[, c(6, 5)]

pred_subtypes$Color <- ifelse(pred_subtypes$PredBailey == "Progenitor", "orange", 
                        ifelse(pred_subtypes$PredBailey == "Squamous", "steelblue", 
                               ifelse(pred_subtypes$PredBailey == "Immunogenic", "red2", "saddlebrown")))
colors_bailey <- c("Progenitor" = "orange", "Squamous" = "steelblue", "Immunogenic" = "red2", "ADEX" = "saddlebrown")

hc_b <- hclust(dist(t(Bai_scaled[, -ncol(Bai_scaled)])), method = "ward.D2")
dend <- as.dendrogram(hc_b)
dend <- set(dend, "labels_cex" , 0.5)

dend_order <- labels(dend)
label_colors <- pred_subtypes[match(dend_order, rownames(pred_subtypes)), "Color" ]
labels_colors(dend) <- label_colors

plot(dend, main = "Dendrogram of the PC Subtypes Prediction")
legend("topright", legend = c("Progenitor", "Squamous", "Immunogenic", "ADEX"),
       fill = colors_bailey,
       border = "black",
       bty = "n", cex = 0.8)

```


```{r prediction of Bailey subtype heatmap, echo = FALSE}
# Heatmap with prediciton of Baileys subtype for the samples and its association
order_bailey <- pred_subtypes[order(pred_subtypes$PredBailey), ]

Bai_scaled_ord <- Bai_scaled[, match(order_bailey$Samples_ID, colnames(Bai_scaled[, -ncol(Bai_scaled)]))]

identical(colnames(Bai_scaled_ord), order_bailey$Samples_ID) # TRUE

heatmap.2(as.matrix(Bai_scaled_ord), main = "Bailey's subtypes signature PC", density.info = "none", trace = "none", dendrogram = "none", col = pal, Rowv=F, Colv = F, RowSideColors=hm_cols_bailey, ColSideColors = order_bailey$Color, na.rm=TRUE, cexRow = 0.02, xlab = "Tumor Samples", ylab = "Genes")
legend("left", legend = unique(names(hm_cols_bailey)), fill = unique(hm_cols_bailey), border = "black", title = "PC Subtypes", cex = 0.7, box.lwd = 0.7)
```


```{r bailey pca, echo= FALSE, cache=TRUE}
trans_bailey_expr  ### Only with the 9078 protein coding genes
pca_pred_bailey <- prcomp(trans_bailey_expr[, ], center = T, scale. = T)

trans_bailey_expr_2 <- trans_bailey_expr
 
trans_bailey_expr_2$Pred_Bailey <- pred_subtypes$PredBailey[match(rownames(trans_bailey_expr_2), rownames(pred_subtypes))]
trans_bailey_expr_2$Sex <- tumors$Sex[match(rownames(trans_bailey_expr_2), rownames(tumors))]

#identical(pred_subtypes$PredBailey, trans_bailey_expr_2$Pred_Bailey) ### TRUE

PCA_BaileyPred <- autoplot(pca_pred_bailey, data = trans_bailey_expr_2, label= F, size = 3, main = "Predicted PC Subtypes - Bailey's Signature", frame = F, colour = "Pred_Bailey", shape = "Sex") + scale_color_manual(values = colors_bailey) + theme_minimal() 

### PC1 = 19.2%
### PC2 = 14.68%

plot(PCA_BaileyPred)

```



# Microbiome

16S rRNA gene amplicon sequencing is most probably done under the hypervariable region V3-V4 of the 16S rRNA sequence. These hypervariable regions are very specific for strains, and are commonly used for taxonomic identification of bacteria.

## DADA2

DADA2 implements an algorithm that models the errors introduced during amplicon sequencing, and uses the error model to infer the true sample composition. DADA2 infers sample sequences exactly, without coarse-graining into OTUs, and resolves differences of as little as one nucleotide. It is used as a quality control process to evaluate the quality of the reads of the 16S rRNA sequencing.

In this study, the DADA2 pipeline tutorial was applied, following the pipeline form the developer's GitHub (<https://benjjneb.github.io/dada2/tutorial.html>) [@callahan2016]. All the steps are extensively described and only small adaptative changes have been applied to this study.

Our starting point is a set of Illumina-sequenced paired-end fastq files that have been split (or “demultiplexed”) by sample and from which the barcodes/adapters have already been removed. The end product is an amplicon sequence variant (ASV) table, which records the number of times each exact amplicon sequence variant was observed in each sample.

### Inspecting Read Quality Profiles

Trimming off low-quality bases and filtering out low quality reads are important steps.

The plots of the quality profiles of the reads per sample indicate the quality scores across all bases in *Illumina* sequencing.

Quality scores over 28% are considered good quality scores. The ends of the sequences usually drop their quality scores, due to sequencing technology limitations. The sequences will be trimmed and filtered by a sequence length that keeps quality scores over 28%.

Other quality control considerations: - Samples undergo several PCR rounds which introduce nucleotide mutations - Environmental contaminants are important to keep in mind, specially if samples contain low DNA biomass (biopsies, blood, cerebrospinal fluid...). The environmental contaminants can come from wet-lab processes (surfaces or instruments with contaminating DNA) or external DNAs. - Non-specific contaminant reads can derive from host DNA (human). - It is important to include a PCR negative control, and an extraction control in the experiment.

```{r data loading, echo=FALSE, cache=TRUE, results='hide', warning=FALSE, message=FALSE}
#Read fastq files: 
data_path <- ("/set/to/working/directory/fastq") #Working directory of the raw files
Fwrd_rds <- paste0(data_path,"/R1/") #Forward Reads
Rvse_rds <- paste0(data_path,"/R2/") #Reverse Reads

#Now we read in the names of the fastq files, and perform some string manipulation to get matched lists of the forward and reverse fastq files.

#head(list.files(Fwrd_rds)) #Pattern of files: "_R1_001.fastq.gz"
#length(list.files(Fwrd_rds)) #139 files
#head(list.files(Rvse_rds)) #Pattern of files: "_R2_001.fastq.gz"
#length(list.files(Rvse_rds)) #139 files, same as Fwrd_rds

fnFs <- sort(list.files(Fwrd_rds, pattern="_R1_001.fastq.gz"))
fnRs <- sort(list.files(Rvse_rds, pattern="_R2_001.fastq.gz"))

fnFs_2 <- paste0(Fwrd_rds, fnFs)
fnRs_2 <- paste0(Rvse_rds, fnRs)

# Extract SAMPLE NAMES. Filenames have format: SAMPLENAME_XXX_RX_001.fastq.gz
sample.names_f <- sapply(strsplit(basename(fnFs), "_"), `[`, 1)
sample.names_r <- sapply(strsplit(basename(fnRs), "_"), `[`, 1)

b <- sample.names_f %in% sample.names_r 
#There are the same sample names in the forward and the reverse filenames. Good. 
```

Inspect **read quality profiles**: visualize the quality profiles of the forward reads.

The plots were obtained using the `plotQualityProfile` function from the `dada2` (v 1.34.0) package.

In gray-scale is a heat map of the frequency of each quality score at each base position. The mean quality score at each position is shown by the green line, and the quartiles of the quality score distribution by the orange lines. Trimming as the average qualities crash will improve the algorithm’s sensitivity to rare sequence variants.

```{r quality profiling fastq forward, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE}
# Visualize the reads quality for the Forward fastq files: 
plotQualityProfile(fnFs_2[10:11], n = 5e+05)  

```

Quality profile of forward reads for two representative samples (FF1 and FF10). The analysis was performed using a DADA2 pipeline. The x-axis shows read length (0–300 bases) and y-axis shows the quality score of the reads (0-40%). Green line represents the median quality score, whereas the orange line represents the quartiles of the quality score distribution at each base position.

Let's look for the point of the sequence in which the quality score drops below 28%. Adjust the x-axis limit over 200, and the y-axis limit below 28. Run this analysis for at least 4 samples to check for validation of the trimming point.

```{r trimming point for forward reads, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE}
#Trying to get the x point at which the quality score drops below 28%:
plotQualityProfile(fnFs_2[10], n = 5e+05) + xlim(200,300) + ylim(0, 28)
```

Quality profile of forward reads for a representative sample (FF1). The analysis was performed using a DADA2 pipeline. The x-axis shows the read length (200–300 bases) and y-axis shows the quality score of the reads limited to 28%. Green line represents the median quality score, whereas the orange line represents the quartiles of the quality score distribution at each base position.

```{r trimming point for forward reads 2, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE}
#Let's try with at leat 3 samples more: 
plotQualityProfile(fnFs_2[11:13], n = 5e+05) + xlim(200,300) + ylim(0, 28)

#Trimming at 250 bp of length for forward sequences. Good. 
```

Quality profile of forward reads for three representative samples (FF10, FF100, FF101). The analysis was performed using a DADA2 pipeline. The x-axis shows the read length (200–300 bases) and y-axis shows the quality score of the reads limited to 28%. Green line represents the median quality score, whereas the orange line represents the quartiles of the quality score distribution at each base position.

All four of the samples show that the value of the quality score of the forward reads drops below 28% around the position 250 of the sequences. The forward reads will be trimmed at 250 bp.

Inspect **read quality profiles**: visualize the quality profiles of the reverse reads.

```{r quality profiling fastq reverse, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE}
# Visualize the reads quality for the Reverse sequencing fastq files: 
plotQualityProfile(fnRs_2 [10:11])

```

Quality profile of the reverse reads for two representative samples (FF1 and FF10). The analysis was performed using a DADA2 pipeline. The x-axis shows read length (0–300 bases) and y-axis shows the quality score of the reads (0-40%). Green line represents the median quality score, whereas the orange line represents the quartiles of the quality score distribution at each base position.

```{r trimming point for reverse reads, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE}
#Trying to get the x point at which the quality score drops below 28%:
plotQualityProfile(fnRs_2[10], n = 5e+05) + xlim(200,300) + ylim(0, 28)
```

Quality profile of the reverse read for a representative sample (FF1). The analysis was performed using a DADA2 pipeline. The x-axis shows the read length (200–300 bases) and y-axis shows the quality score of the reads limited to 28%. Green line represents the median quality score, whereas the orange line represents the quartiles of the quality score distribution at each base position.

```{r trimming point for reverse reads 1, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE}
#Let's try with at leat 3 samples more: 
plotQualityProfile(fnRs_2[11:13], n = 5e+05) + xlim(200,300) + ylim(0, 28)

#Trimming at 200 bp of length for reverse sequences 
```

Quality profile of reverse reads for three representative samples (FF10, FF100, FF101). The analysis was performed using a DADA2 pipeline. The x-axis shows the read length (200–300 bases) and y-axis shows the quality score of the reads limited to 28%. Green line represents the median quality score, whereas the orange line represents the quartiles of the quality score distribution at each base position.

All four of the samples show that the value of the quality score of the forward reads drops below 28% around the position 200 of the sequences. The reverse reads will be trimmed at 200 bp and filtered accordingly.

Forward reads (F) always show better quality than reverse reads (R). Reads were trimmed to lengths of 250 bp and 200 bp for the forward and reverse reads, respectively, to conserve quality score of the reads over 28%. This step was performed using the `filterAndTrim` function from `dada2` package.

```{r trimming and filtering of samples, echo= FALSE, warning=FALSE, message=FALSE, cache =TRUE}
#Create directory for new filtering files:
filt_path_R1 <- file.path("/set/to/working/directory/filtered_R1") #Working directory of the raw files
filt_path_R2 <- file.path("/set/to/working/directory/filtered_R2") #Working directory of the raw files

#Define the name of the output files:
filt_F <- file.path(filt_path_R1, paste0(sample.names_f, "_F_filt.fastq.gz"))
filt_R <- file.path(filt_path_R2, paste0(sample.names_r, "_R_filt.fastq.gz"))

#Trimming and Filtering
out <- filterAndTrim(fnFs_2, filt_F, fnRs_2, filt_R, truncLen = c(250, 200), 
                     maxN=0, maxEE = c(2,2), truncQ = 2, rm.phix = TRUE, compress = TRUE)

#dim(out) #139 files --> No samples have been lost due to the filtering step. 
#kable(head(out))
#mean(out[, 1])
#mean(out[, 2])

```

### Error Rate Estimation

The DADA2 algorithm makes use of a parametric error model (err) and every amplicon dataset has a different set of error rates, each sequencing batch will have a different error rate. This algorithm follows a machine learning approach with a training subset of the samples to develop the model, and the test subset. The algorithm does 5 rounds of iterations to test the model developed by the training subset of data. The `learnErrors` function from the `dada2` package was used, as it learns the error rates from an input list of fastq file names.

```{r error rate estimation forward, echo=FALSE, warning=F, message = FALSE, cache=TRUE}
#Learn an error profile from filtered reads
#For the forward reads:
err_F <- learnErrors(filt_F, randomize = TRUE, verbose = TRUE, multithread = TRUE)

#Plotting the error rates for each possible transition. 
plotErrors(err_F, nominalQ=TRUE)
```

```{r error rate estimation reverse, echo=FALSE, warning=F, message = FALSE, cache=TRUE}
#Now for reverse reads
err_R <- learnErrors(filt_R, randomize = TRUE, verbose = TRUE, multithread = TRUE)

plotErrors(err_R, nominalQ=TRUE)
```

The error rates for each possible transition (A \> C, A \> G, …) are shown. Points are the observed error rates for each consensus quality score. The black line shows the estimated error rates after convergence of the machine-learning algorithm. The red line shows the error rates expected under the nominal definition of the Q-score. The estimated error rates (black line) are a good fit to the observed rates (points), and the error rates drop with increased quality as expected.

Everything looks reasonable and we proceed with the analysis.

### Sample Inference

Apply the core sample inference algorithm to the filtered and trimmed sequence data. Using the error model trained from the dataset, it is possible to discriminate which reads are representative of our experiment and which are resulting from sequencing errors or other artifacts.

Null hypothesis: a sequence with a given error rate is too abundant to be explained by sequencing errors. Low quality reads are filtered out (reads with high p-value likely generated by sequencing errors).

```{r sample inference, echo = FALSE, warning = FALSE, cache=TRUE, results='hide'}
#Sample Inference
dada_F <- dada(filt_F, err=err_F, multithread=TRUE) #Information of all the sequences by each sample  
#head(dada_F$FF1_F_filt.fastq.gz)
#saveRDS(dada_F, "/set/to/working/directory/dada_F.RData")

dada_R <- dada(filt_R, err=err_R, multithread=TRUE)
#head(dada_R$FF1_R_filt.fastq.gz)
#saveRDS(dada_R, "/set/to/working/directory/dada_R.RData")

# dada_F[[1]] # dada-class: object describing DADA2 denoising results
              # 1721 sequence variants were inferred from 171254 input unique sequences.
              # Key parameters: OMEGA_A = 1e-40, OMEGA_C = 1e-40, BAND_SIZE = 16
```

### Merge paired end reads

Merging the forward and reverse reads together to obtain the full denoised sequences. Merging is performed by aligning the denoised forward reads with the reverse-complement of the corresponding denoised reverse reads, and then constructing the merged “contig” sequences. By default, merged sequences are obtained if the forward and reverse reads overlap by at least 12 bases, and are identical to each other in the overlap region

```{r merging paired end reads, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE}
#Merge paired end reads
merged <- mergePairs(dada_F, filt_F, dada_R, filt_R, verbose = TRUE)

#saveRDS(merged, "/set/to/working/directory/merged.RData")

# Inspect the merger data.frame from the first sample
# head(merged[[1]])
```

The merged object is a list of `data.frames` from each sample.

### Sequence table

Constructing amplicon sequence variant (ASV) table.

```{r amplicon sequence variant table, echo=FALSE, cache=TRUE, results ='hide', message=FALSE}
seq_tab <- makeSequenceTable(merged)
dim(seq_tab) #This table contains 29506 ASV for each of the samples

# Inspect distribution of sequence lengths
table(nchar(getSequences(seq_tab)))
max(table(nchar(getSequences(seq_tab)))) #Position number 290
dim(table(nchar(getSequences(seq_tab)))) #189 positions
sum(table(nchar(getSequences(seq_tab)))[1:61]) #17378 ASVs compressed between positions 250 and 310 

17378/29506 #58.89%

```



### Removing chimeras

```{r removing chimeras, echo=FALSE, message=FALSE, cache=TRUE, results='hide'}
seqtab_nochim <- removeBimeraDenovo(seq_tab, method="consensus", multithread=TRUE, verbose=TRUE)
dim(seqtab_nochim) # 139 samples and 14987 reads with no chimera

#Proportion of chimeras in our reads
sum(seqtab_nochim)/sum(seq_tab) #0.6840836 --> 68.41% of the reads were no-chimeric
1-sum(seqtab_nochim)/sum(seq_tab) #0.3159164 --> 31.59% of the reads were chimeric


#Saving this seqtab_nochim file 
class(seqtab_nochim) #matrix, array
rownames(seqtab_nochim) <- paste0(sample.names_f, "_filt.fastq.gz")
#write.csv(seqtab_nochim, "/set/to/working/directory/filt_reads.csv")

```

Here chimeras make up about 31.59% of the merged sequence reads. Chimeric sequences are filtered out from the analysis data. Finally, we continue the analysis with a dataframe of 139 samples and 14987 non-chimeric sequencing reads.

### Tracking filtering steps

As a final check of the progress, look at the number of reads that made it through each step in the pipeline.

```{r tracking filtering steps, echo=FALSE, cache=TRUE, results='hide'}

getN <- function(x) sum(getUniques(x))
track <- cbind(out, sapply(dada_F, getN), sapply(dada_R, getN), sapply(merged, getN), rowSums(seqtab_nochim))
# If processing a single sample, remove the sapply calls: e.g. replace sapply(dadaFs, getN) with getN(dadaFs)
colnames(track) <- c("Input", "Filtered", "Denoised_F", "Denoised_R", "Merged", "Non_chim")
rownames(track) <- sample.names_f
head(track)

as.data.frame(track)
summary(track)

#Saving the tracking object
# write.csv(track, "/set/to/working/directory/track_filt_reads.csv")
```

We have removed a big part of the raw reads by the filtering steps. The difference of reads is noticeable comparing the "Input" and "Non_chim" columns.

**Sanity check**: There should be no step in which a majority of reads are lost. Checking the summary, there seems to be no extravagant loss of number of reads.

```{r sanity check of the filtering steps, echo=FALSE, warning=FALSE, message=FALSE, cache=TRUE}
#Loading the tracking data
track <- read.csv("/set/to/working/directory/track_filt_reads.csv", row.names=1)
colnames(track)[4] <- "Denoised_R"

# Plotting the mean number of reads in each step
means_track <- colMeans(track)
track$Samples <- rownames(track)
means_track <- as.data.frame(means_track)
means_track$step <-rownames(means_track)
colnames(means_track) <- c("Mean_reads", "Step")
means_track$Step <- factor(means_track$Step, levels = c("Input", "Filtered", "Denoised_F", "Denoised_R", "Merged", "Non_chim"))

g_filt_reads <- ggplot(means_track, aes(x = Step, y=Mean_reads, fill = Step)) + geom_bar(stat= "identity", alpha = 1.5, colour="black", lwd = 0.2) + scale_fill_manual(values =c("lightsteelblue1", "darkolivegreen1", "mistyrose", "mistyrose", "tan1", "gold" )) +  theme_minimal() + xlab("DADA2 Step") + ylab("Mean Nº of Reads") + labs(title="Mean Reads per Step of the DADA2 pipeline")

g_filt_reads
```


Let's calculate the percentage of reads that passed the filtering steps.

```{r percentage of reads after filtering, echo=FALSE, warning=FALSE, results= 'hide', cache=TRUE}
#Create column in track data.frame
track$Perc <- round((track$Non_chim/track$Input)*100, 4)

#Calculating the mean of the percentage of reads that survived the quality control filtering:
means_track[7, 1] <- mean(track$Perc)
rownames(means_track)[7] <- "Percentage_f"
#By mean, there is an 11.36% of reads that surpassed the quality control steps. 

#Checking which are the samples that get a percentage below 1%
no_qc_samples <- track[track$Perc < 1, ]
no_qc_samplenames <- rownames(no_qc_samples)  #"CN076"  "CNE"    "CNE76"  "CNLane" "FF21"   "FF25"   "Mock1"  "Mock2"  "Mock3" 

#Calculating again the mean of percentage of reads that passed the quality control, without the samples with <1%:
track_no_qc <- track[!rownames(track) %in% c("CN076", "CNE", "CNE76", "CNLane", "FF21", "FF25", "Mock1",  "Mock2", "Mock3"), ] #130 samples
track_no_qc$Perc <- round((track_no_qc$Non_chim/track_no_qc$Input)*100, 4)
means_track_noqc <- means_track
means_track_noqc[7, 1] <- mean(track_no_qc$Perc)
#Having removed the samples with a percentage <1%, the mean of reads that surpassed the qc steps is = 12.14%. 

#Saving the track_no_qc object as well:
#write.csv(track_no_qc, "/set/to/working/directory/track_reads_posqc.csv")
```

By mean, an 11,36% of the reads passed the filtering steps done by the quality control pipeline of DADA2.

The samples: "CN076" "CNE" "CNE76" "CNLane" "FF21" "FF25" "Mock1" "Mock2" "Mock3" don't meet the quality control criteria: in the end of the DADA2 pipeline, these samples contain less than 1% of the input reads.

After removing the samples that present the counts of reads below 1% after the DADA2 pipeline, by mean, a 12,14% of the reads passed the filtering steps.

The samples FF21 and FF25 corresponded to 2 samples labeled as "Control" samples: retrieved from healthy pancreatic tissue. Therefore, there are 30 samples remaining to the "Control" group. 
"CNE"s and "Mock" samples were negative controls for the experiment. 


```{r fraction of seqs, echo=FALSE, cache=TRUE, warning=FALSE}
# Taula TFM: processament dels reads i quantitat de reads que em queden per l'anàlisi
table_1 <- t(means_track_noqc[, c(2, 1)])
table_1 <- as.data.frame(table_1)
table_1 <- table_1[2,]

#write.csv(table_1, "/set/to/working/directory/Mean_reads_tracking.csv")
```


## Taxonomic Assignment

Analysis of the bacterial community from a 16S rRNA amplicon data includes comparing the reads to a reference database. A successful annotation depends on the quality of the raw data and the reference database. To process amplicon sequencing data from raw reads to taxa abundance tables, several bioinformatic pipelines have been developed: Quantitative Insights intoMicrobial Ecology 2 (QIIME2, Bolyen et al., 2019), DADA2 (Callahan et al., 2016), and mothur (Schloss et al., 2009). All these pipelines involve mapping reads to taxonomical reference databases. Three common standard 16S rRNA databases are SILVA (Quast et al., 2013), Greengenes (McDonald et al., 2012), and RDP (Wang et al., 2007). These databases also differ significantly in their size, content, and how they are curated.

16S rRNA sequencing presents low species taxa discrimination capacity because of gene homology between some species [@gwak2020]. Strategies are warranted to enhance taxonomic classification of 16S RNA sequencing data and obtain more accurate insights into the microbial composition of samples. Therefore, a protocol developed by ([@bars-cortina2023]) has been used to obtain a high quality, improved, taxonomic classification of the amplicon sequence variants (ASV) from the raw reads of this study.

The improved taxonomic assignment has been obtained by combinint he outputs of three different protocols: 

* **Protocol 1**: the default taxonomy assignment obtained from SILVA v.138.1 databases through `DADA2` functions `assignTaxonomy` and `addSpecies`. The output was a dataframe of 14987 sequences (rows) with their assignment to 7 taxonomic levels (columns). The assignment is not very accurate. 

* **Protocol 2**: it describes the process to create a custom BLASTN database (constructed from the SILVA v138.1 database) that will be used to classify the ASV sequences obtained in Protocol 1. Moreover, a specific lineage will be obtained based on E-value and percentage of identical matches parameters from the BLAST tool. In this study, an E-value = 1e-2 and pident = 90% parameters were used. Duplicated ASVs were manually removed by consulting bibliography, and taxa not belonging to human microbiome was also removed. The output was a table of 829 ASVs that were identified with  full lineages. 

* **Protocol 3**: this protocol uses the 16S database from NCBI to classify the ASV sequences obtained from the DADA2 pipeline. For this purpose, the k-mer taxonomical classification algorithm of Kraken2 and Bracken2 are used, creating a custom database. A value of confidence = 0.05 and threads = 12 were used with the Kraken2 parameters (https://github.com/DerrickWood/kraken2/issues/167). The Bracken database was used to assign taxonomies at a species level (l=S), found, at least, in 1 ASV.  The output is a data frame of 54 ASVs with a full species taxonomy assignment.

* **Protocol 4**: This protocol takes as input the output of the previous Protocol 1, Protocol 2 and Protocol 3, and combines them in order to obtain a complete taxonomy assignment at a species level, for the maximum of ASVs sequences in the 16S rRNA assay. Mitochondria, chloroplasts and eukaryota taxonomies were filtered out from the results. The ASVs with low library depth (LD) were filtered out from the results (ASVs(LC) > threshold = LD * 0.000005). 

The output of the entire protocol is a phyloseq object. 


```{r building the ps object, echo=FALSE, results='hide', cache=TRUE, warning=FALSE, message=FALSE}
# Loading metadata
meta_ps <- read.csv("/set/to/working/directory/final_metadata.csv", sep= ",", header = T, row.names = 1)
## 127 samples --> Good
## Contains CNE and the samples not passing the DADA2 qc are removed. 

# Output file generated by Protocol 4:
asv_table_16S <- readRDS("/set/to/working/directory/asv_table_16S.rds")
dim(asv_table_16S) 
# 40 ASVs + 139 samples --> It still has the negative controls and the mock samples and samples that did not pass the quality control from DADA2
#Removing the samples that did not pass the quality control from the seqtab_nochim (< 1% reads after DADA2): 
no_dada2 <- c("CN076", "CNE", "CNE76", "CNLane", "FF21", "FF25", "Mock1",  "Mock2", "Mock3")
asv_table <- asv_table_16S [ , ! (colnames(asv_table_16S) %in% no_dada2)]

asv_table <- t(asv_table)
asv_table <- asv_table[! rownames(asv_table) %in% c("FF96", "FF95", "FF107"), ]
dim(asv_table)
#127 samples and 40 different identified taxa
### --> This will be used in the phyloseq object
cne_yes <- rownames(asv_table)[grep("^CN", rownames(asv_table))]
cne_yes #"CN276"  "CN2E76" "CN76"   "CN8576" "CNE76m"


sample_ps <- meta_ps[ , c("FF_Number", "Group", "Sex", "Age", "Hospital", "mg_tissue")]
rownames(sample_ps) <- sample_ps$FF_Number
sample_ps <- sample_ps[order(rownames(sample_ps)), ]

identical(rownames(sample_ps), rownames(asv_table)) #TRUE. Proceed to create the phyloseq object

sample_ps <- sample_ps[, -1]

sample_ps <- merge(sample_ps, metadata_final[, colnames(metadata_final) %in% c("FF_ID", "Age")], by.x = "row.names", by.y = "FF_ID", all.x = TRUE)
sample_ps <- sample_ps[, ! colnames(sample_ps) %in% c("Age.x")]
colnames(sample_ps)[colnames(sample_ps) == "Age.y"] <- "Age"
colnames(sample_ps)[colnames(sample_ps) == "Row.names"] <- "FF_ID"
rownames(sample_ps) <- sample_ps$FF_ID

##############
## Phyloseq ##
##############

OTU_ps <- otu_table(asv_table, taxa_are_rows = F)
head(taxa_names(otu_table(OTU_ps))) # works

xnames = colnames(asv_table)
shortnames = gsub(paste0(".+\\",";"), "", xnames)
x2 = strsplit(xnames, split=";", fixed = T)
taxmat = matrix(NA, ncol=max(sapply(x2,length)), nrow = length(x2))
colnames(taxmat) = c("Kingdom","Phylum", "Class", "Order", "Family", "Genus", "Species")[1:ncol(taxmat)]
rownames(taxmat) = colnames(asv_table)
for (i in 1:nrow(taxmat)){
  taxmat[i, 1:length(x2[[i]])] <- x2[[i]] 
  }

head(taxmat)
tax_ps = phyloseq::tax_table(taxmat)
```


```{r displaying the ps object, echo=FALSE, results='hide', cache=TRUE, warning=FALSE, message=FALSE}
##### Phyloseq
ps <- phyloseq(OTU_ps, 
               sample_data(sample_ps), 
               tax_ps, 
               include_all=TRUE)
ps #Good

# phyloseq-class experiment-level object
# otu_table()   OTU Table:         [ 40 taxa and 127 samples ]
# sample_data() Sample Data:       [ 127 samples by 6 sample variables ]
# tax_table()   Taxonomy Table:    [ 40 taxa by 7 taxonomic ranks ]


#Exploring how many genus:
ps_genus <- tax_glom(ps, taxrank = "Genus")
ps_genus
# phyloseq-class experiment-level object
# otu_table()   OTU Table:         [ 27 taxa and 127 samples ]
# sample_data() Sample Data:       [ 127 samples by 6 sample variables ]
# tax_table()   Taxonomy Table:    [ 27 taxa by 7 taxonomic ranks ]


#Exploring how many species:
ps_species <- tax_glom(ps, taxrank = "Species")
ps_species
# phyloseq-class experiment-level object
# otu_table()   OTU Table:         [ 19 taxa and 127 samples ]
# sample_data() Sample Data:       [ 127 samples by 6 sample variables ]
# tax_table()   Taxonomy Table:    [ 19 taxa by 7 taxonomic ranks ]


# saveRDS(ps, file="/set/to/working/directory/ps.rds")
# saveRDS(ps_genus, file="/set/to/working/directory/ps_genus.rds")
# saveRDS(ps_species, file = "/set/to/working/directory/ps_spp.rds")


total.depth <- sum(taxa_sums(ps))   ### 982860
threshold <- 0.000005 * total.depth ### 4.9143
abundant.taxa <- (taxa_sums(ps) > threshold)
ps_filtered <- prune_taxa(abundant.taxa, ps)
ps_filtered@otu_table
### 27 taxa

sample_sums(tax_glom(ps_filtered, taxrank = "Species"))

```


```{r cleaning ps_, echo=FALSE, results='hide', cache=TRUE}
rownames(ps_species@otu_table)
neg_controls <- c("CN276", "CN2E76", "CN76", "CN8576", "CNE76m")
sample_sums(ps@otu_table[rownames(ps@otu_table) %in% neg_controls, ])
#    CN276 CN2E76   CN76 CN8576 CNE76m 
#        0  14070     59     14     66
```


```{r cleaning ps at genus level, echo=FALSE, results='hide', cache=TRUE}
sample_sums((tax_glom(ps, taxrank = "Genus"))@otu_table[rownames((tax_glom(ps, taxrank = "Genus"))@otu_table) %in% neg_controls, ])
#    CN276 CN2E76   CN76 CN8576 CNE76m 
#        0   7120      0      0      0    -->   6899 of them are Clostridioides difficile
sort(sample_sums(ps_genus@otu_table))
# head((tax_glom(ps, taxrank = "Genus"))@otu_table)   # CN2E76: 6899 Clostridioides difficile
```


### Library Depth 

Exploring the phyloseq data and the library depth among samples. 

```{r exploring the ps data, echo=FALSE, results='hide', cache=TRUE}
#Get reads per sample, sort and plot
sort(sample_sums(ps)) 
# hist(sample_sums(ps), main = "Histogram: Read Counts - ps", xlab="Total Reads to Analyze", col="gold", breaks= 125)
shapiro.test(sample_sums(ps_genus))   # p-value = 1.139e-12 --> We will have to compute the non-parametric tests

sort(sample_sums(ps@otu_table[rownames(ps@otu_table) %in% neg_controls, ]), decreasing = TRUE)
#  CN2E76 CNE76m   CN76 CN8576  CN276 
#   14070     66     59     14      0 
```

```{r histogram read counts ps, echo=FALSE, cache=TRUE}
#Histogram of the library depth of the ps object 
hist(sample_sums(ps), main = "Histogram: Read Counts - ps", xlab="Total Reads to Analyze", col="gold", breaks= 125)
```


```{r exploring the ps_species data, echo=FALSE, cache=TRUE, results='hide'}
sort(sample_sums(ps)) #The sample with the most reads is the CN2E76 
```

```{r histogram read counts ps_species, echo=FALSE, cache=TRUE}
#Histogram of the library depth of the ps_species object 
hist(sample_sums(ps_species), main = "Histogram: Read Counts - ps_species", xlab="Total Reads to Analyze", col="darkblue", breaks= 80)
```


Exploring differences with the negative controls:

```{r differences in library size by sample group with cne, echo=FALSE, message=FALSE, cache=TRUE}
## Library depth for each of the samples in each group
o <- data.frame(sample_data(ps))
o$ls <- sample_sums(ps)
o$Group <- as.factor(o$Group)

ls_by_samplegroup <- ggplot(o, aes(x=factor(Group, levels=c("Control", "Adjacent", "Tumor", "CNE")), y=ls)) +
  geom_boxplot(aes(fill =Group), alpha= 0.5) + 
  geom_jitter(aes(colour = Group), alpha= 0.8, show.legend = FALSE) +
  theme_minimal() + 
  ylab("Library Size") + xlab("Group") + ggtitle("Library Size by Sample Group") +
  scale_fill_manual(values = colors_sam) +
  scale_color_manual(values = colors_sam) +
  labs(fill = "Group") +
  stat_compare_means(paired=FALSE)

plot(ls_by_samplegroup)
``` 

Box plot with the distribution of the total number of reads depending on the group of the sample. The Kruskal-Wallis statistical test is used to test significant differences between the 4 groups. The result of the test (Kruskal Wallis p-value = 0.024) indicates that there are statistical significant differences in the number of reads in the experimental negative controls (CNE). 

This is the expected result in this case. 

```{r differences in library size by sample group with cne 2, echo=FALSE, message=FALSE, cache=TRUE, results='hide'}
# Kruskal Wallis, p-value = 0.024 --> The control has significantly less counts of reads  --> This is what we expected

kruskal.test(sample_sums(ps@otu_table)~ps@sam_data$Group) # p-val = 0.02409
kruskalmc(sample_sums(ps@otu_table)~ps@sam_data$Group) ## All the groups present statistical differences with CNE. No statistical differences between them. 
```


Let's do a Sensitivity analysis (filtering out the highest read counts from each group) to validate the robustness about the significant differences found comparing the groups with the CNE. 

```{r Sensitivity analysis, echo=FALSE, cache=TRUE, results = 'hide'}
# Doing a Sensitivity analysis with the library counts from each group:
# Removing the samples with the highest number of counts from each case, and repeating the Kruskal Wallis test, to determine if the differences are still significant

# Highest number of reads from CNE: 
neg_controls <- c("CN276", "CN2E76", "CN76", "CN8576", "CNE76m")
sens_test_cne <- names(sort(sample_sums(ps@otu_table[rownames(ps@otu_table) %in% neg_controls, ]), decreasing = TRUE)[1])   #"CN2E76"

# Highest number of reads from Control Gps_species# Highest number of reads from Control Group
ctrl_names <- rownames(ps@sam_data)[ps@sam_data$Group == "Control"]
sens_test_ctrl <- names(sort(sample_sums(ps@otu_table[rownames(ps@otu_table) %in% ctrl_names, ]), decreasing =TRUE)[1])


# Highest number of reads from Tumor Group
tumor_names <- rownames(ps@sam_data)[ps@sam_data$Group == "Tumor"]
sens_test_tumor <- names(sort(sample_sums(ps@otu_table[rownames(ps@otu_table) %in% tumor_names, ]), decreasing =TRUE)[1])

# Highest number of reads from Adjacent Group
adj_names <- rownames(ps@sam_data)[ps@sam_data$Group == "Adjacent"]
sens_test_adj <- names(sort(sample_sums(ps@otu_table[rownames(ps@otu_table) %in% adj_names, ]), decreasing =TRUE)[1])


highest_ld <- c(sens_test_cne, sens_test_ctrl, sens_test_tumor, sens_test_adj)


ps_sens_test <- phyloseq(otu_table(ps@otu_table[! rownames(ps@otu_table) %in% highest_ld]), 
                         sample_data(ps@sam_data[!rownames(ps@sam_data) %in% highest_ld]), 
                         tax_ps)

ps_sens_test #Good
```


```{r Sensitivity analysis 2, echo=FALSE, cache=TRUE}

LS_by_group_senstest <- ggplot((ps_sens_test@sam_data), aes (x=factor(ps_sens_test@sam_data$Group, levels = c("Adjacent", "Control", "Tumor", "CNE")), y=sample_sums(ps_sens_test))) +
  geom_boxplot(aes(fill =ps_sens_test@sam_data$Group), alpha= 0.5) + 
  geom_jitter(aes(colour = ps_sens_test@sam_data$Group), alpha= 0.8, show.legend = FALSE) +
  theme_minimal() + 
  ylab("Library Size") + xlab("Group") + ggtitle("Library Size by Sample Group - Sensitivity Analysis") +
  labs(fill = "Group") +
  scale_fill_manual(values = colors_sam) +
  scale_color_manual(values = colors_sam) +
  stat_compare_means(paired=FALSE)


plot(LS_by_group_senstest)


## Kurskal Wallis p-value = 0.0018 --> Significant differences with CNE --> Good: Discarding the CNE

kruskal.test(sample_sums(ps_sens_test@otu_table)~ps_sens_test@sam_data$Group) # 0.001803
kruskalmc(sample_sums(ps_sens_test@otu_table)~ps_sens_test@sam_data$Group) # All the groups present statistical differences with the CNE group
```
Box plot with the distribution of the total number of reads depending on the group of the sample. The Kruskal-Wallis statistical test is used to test significant differences between the 4 groups. The result of the test (Kruskal Wallis p-value = 0.0018) indicates that there are statistical significant differences in the number of reads in the experimental negative controls (CNE). 


Are there library size differences between Normal_paired and Control and Tumor?
To inspect these differences, the CNE will be removed from the phyloseq object. We're creating the clean phyloseq object. 

The clean phyloseq object is built by filtering out the negative controls: 
- CN2E76 is one of the samples with most reads (14070 reads), and it contains high variability of taxonomies (10 different taxonomies), including bacteria identified at a species level (7120 reads identified at a species level).
- CN276, CN76, CN8576 and CNE76m present a very low count of reads (139 reads summing up all of them), and these have only been identified at a Kingdom and Phylum level (very superficial information). 
With all this information, and taking into account possible labeling error (https://doi.org/10.1093/bioinformatics/btl346), we discard CN2E76 as negative control sample, and only take into account CN276, CN76, CN8576 and CNE76m. Since these samples do not present specific bacteria identification, no contaminants are considered to be filtered out from the data. 

The protocol used to improve the species taxonomic assignment (doi: 10.1002/cpz1.930) provided 40 different taxonomic assignments, 19 of them are specific for species. The function `clean_pq` from the package `MiscMetabar` (v0.14.2) in R (v4.4.3) has been used as tool to remove empty samples and taxa from the phyloseq object. This way, we obtain a clean phyloseq object: without background noise of the negative controls, and no empty samples nor taxa. Moreover, the `clean_pq` function checks for discrepancy (and rename) between (i) taxa names in refseq, taxonomy table and otu_table and between (ii) sample names in sam_data and otu_table.

Finally, the ps_clean object contains 32 taxa and 122 samples (8 taxa have been removed). From the 32 taxa kept, 21 have been identified at a genus level. 


```{r ps_clean designing, echo=FALSE, results='hide', cache=TRUE, message= FALSE, warning=FALSE}
# Designing ps_clean :

###Firstly, determining the taxa found in the CNE: 

sample_sums(ps@otu_table[rownames(ps@otu_table) %in% neg_controls])    # CN276 CN2E76   CN76 CN8576 CNE76m 
                                                                       #     0  14070     59     14     66 
names(which(colSums(ps@otu_table[rownames(ps@otu_table) %in% neg_controls, ]) != 0))

### Doing the same, but not considering CN2E76 as a CNE
sample_sums(ps@otu_table[rownames(ps@otu_table) %in% c("CN276", "CN76", "CN8576", "CNE76m")]) 
# CN276   CN76 CN8576 CNE76m 
#     0     59     14     66    = 139
names(which(colSums(ps@otu_table[rownames(ps@otu_table) %in% c("CN276", "CN76", "CN8576", "CNE76m"), ]) != 0))

names(which(colSums(ps@otu_table[rownames(ps@otu_table) %in% c("CN2E76"), ]) != 0))  

####  ps_nocne: Discarding CNE

ps_nocne <- phyloseq(otu_table(ps@otu_table[! rownames(ps@otu_table) %in% neg_controls]), 
                         sample_data(ps@sam_data[!rownames(ps@sam_data) %in% neg_controls]), 
                         tax_ps)

ps_nocne #Good
# phyloseq-class experiment-level object
# otu_table()   OTU Table:         [ 40 taxa and 122 samples ]
# sample_data() Sample Data:       [ 122 samples by 6 sample variables ]
# tax_table()   Taxonomy Table:    [ 40 taxa by 7 taxonomic ranks ]


## Low abundance taxonomies:
sort(colSums(ps_nocne@otu_table), decreasing=FALSE)

# Convert counts to relative abundances for normalization ("transform_sample_counts" function)
ps_RA <- transform_sample_counts(ps_nocne, function(x) x/sum(x))
        #  phyloseq-class experiment-level object
        #          otu_table()   OTU Table:         [ 40 taxa and 122 samples ]
        #          sample_data() Sample Data:       [ 122 samples by 6 sample variables ]
        #          tax_table()   Taxonomy Table:    [ 40 taxa by 7 taxonomic ranks ]
  

ps_clean <- clean_pq(ps_nocne,     # clean_pq is a function designed to remove empty samples and taxa
  remove_empty_samples = TRUE, remove_empty_taxa = TRUE, clean_samples_names = TRUE, silent = FALSE, verbose = FALSE, 
  force_taxa_as_columns = FALSE, force_taxa_as_rows = FALSE, reorder_taxa = FALSE, rename_taxa = FALSE, 
  simplify_taxo = FALSE, prefix_taxa_names = " ")

### Cleaning function suppresses 8 taxa. 

ps_clean #Good
#    phyloseq-class experiment-level object
#    otu_table()   OTU Table:         [ 32 taxa and 122 samples ]
#    sample_data() Sample Data:       [ 122 samples by 6 sample variables ]
#    tax_table()   Taxonomy Table:    [ 32 taxa by 7 taxonomic ranks ]

#saveRDS(ps_clean, file="/set/to/working/directory/ps_clean.rds")

write.csv(as.data.frame(ps_clean@tax_table), "/set/to/working/directory/identified_taxa.csv")

ps_clean_genus <- tax_glom(ps_clean, taxrank = "Genus")
#    phyloseq-class experiment-level object
#    otu_table()   OTU Table:         [ 21 taxa and 122 samples ]
#    sample_data() Sample Data:       [ 122 samples by 6 sample variables ]
#    tax_table()   Taxonomy Table:    [ 21 taxa by 7 taxonomic ranks ]

``` 


```{r library size differences between groups, echo=FALSE, cache=TRUE}
# Shapiro test to analyze if sample reads follow a normal distribution
shap_5 <- shapiro.test(sample_sums(ps_clean@otu_table)) # p-value = 7.917e-08 --> We have to do non-parametric tests

#Plotting library sizes without CNE and comparing with Kruskal Wallis (non parametric test)
ls_no_cne <- ggplot((ps_clean@sam_data), aes (x=ps_clean@sam_data$Group, y=sample_sums(ps_clean))) +
  geom_boxplot(aes(fill =ps_clean@sam_data$Group), alpha= 0.5) + 
  geom_jitter(aes(colour = ps_clean@sam_data$Group), alpha= 0.8, show.legend = FALSE) +
  theme_minimal() + 
  ylab("Library Size") + xlab("Group") + ggtitle("Library Size by Sample Group") +
  labs(fill = "Group") +
  scale_fill_manual(values = colors_sam) +
  scale_color_manual(values = colors_sam) +
  stat_compare_means(paired=FALSE)

plot(ls_no_cne)

kruskal.test(sample_sums(ps_clean@otu_table)~ps_clean@sam_data$Group) # 0.1602
```

Plotting rarefaction curves to determine sequencing depth of the samples.

```{r rarefaction curves, echo = FALSE, message=FALSE, cache=TRUE}
# Plot the rarefaction curves
rarecurve(as(otu_table(ps_clean), "matrix"), step=100, cex=0.5, title("Rarefaction curves with sequencing depth of the samples"), xlab = "Nº of Bacterial reads", ylab = "Taxa")

```

Rarefaction curves with the Nº of Reads corresponding to bacterial sequences, against Nº of Different taxa, for each of the samples in the study.

Most of the rarefaction curves arrived at the plateau, indicating that, as the number of bacterial reads (sequencing depth of the samples) increases, the number of identified species does not. 

Rarefaction curve plot shows the number of ASVs as a function of the read number. Most of the curves reach asymptote at a sequencing depth lower than 15000 reads, where most taxonomic tags are captured.


### Library Size vs Sample Weight

As a part of the quality control and the normalization processes, a correlation test between the library sizes of the samples and the sample weights is done, to discover if it is necessary to normalize by the sample weight. 

Combining the library depth of each sample and the sample weight, in order to identify a correlation between the library size and the weight of the samples. Validating the result with a correlation test by Spearman's method.  Normalization steps will be performed based on the result of the test. 

```{r combining library depth and sample weight, echo=FALSE, cache=TRUE, warning = FALSE}
#Preparing the data in the same dataframe to plot afterwards:
mirror_df_ls_2 <- data.frame(SampleID = rownames(ps_clean@otu_table), Lib_size = sample_sums(ps_clean))
mirror_df_sw_2 <- data.frame(SampleID = rownames(ps_clean@sam_data), mg_tissue = ps_clean@sam_data$mg_tissue)
mirror_df_2 <- merge(mirror_df_ls_2, mirror_df_sw_2, by.x="SampleID", by.y = "SampleID")


cor.test_lb_sw <- cor.test(mirror_df_2$Lib_size, mirror_df_2$mg_tissue, method = "spearman")  ### p-value = 0.3514, rho = 0.08509
##### --> R= 0.08509
##### --> Weak association of the variables: library size is not influenced by the sample weights

ggscatter(mirror_df_2, x = "mg_tissue", y = "Lib_size", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "spearman",
          xlab = "Sample weight (mg)", ylab = "Library size", main=("Spearman's correlation"))
```

Scatter plot with the correlation of the sample weight (mg) and the library size of each of the samples that passed the quality control. The correlation test in Spearman's method reveals a no-significant correlation between the variables: R = 0.085 and p-value = 0.35. 


```{r mirror plot, echo=FALSE, cache=TRUE}

#Plotting - Mirror bar plot
mirror_plot_corr <- ggplot() +
  geom_col(data = mirror_df_2, 
            aes(x = SampleID, y=(Lib_size), fill = Lib_size), 
            colour= "black", lwd = 0.1) + 
  scale_fill_gradient(name = "Library Size", 
                      low = "#9ECFDD", high = "#244D7F", guide = "colourbar") + 
  new_scale_fill() +
  geom_col (data = mirror_df_2, 
            aes(x = SampleID, y= -(mg_tissue)*(25000/ 0.12), fill = mg_tissue), 
            colour= "black", lwd=0.1)+
  scale_fill_gradient(name = "Sample Weight (mg)", 
                      low = "#AADD9C", high = "#256D3D", guide = "colourbar") + 
  scale_y_continuous( name= "Library Size", breaks = seq(0, 25000, 5000),
                      sec.axis = sec_axis (~ .*-(0.12/25000), 
                                           name= "Sample Weight (mg)", breaks = seq(0, 0.12, 0.01))) + 
  xlab("Samples") + ggtitle ("Mirrored Bar Plot: Library Size + Sample Weight") + 
  theme_classic() + 
  theme( axis.text.x = element_text(angle=45, hjust = 1, size = 3.5), 
         axis.title.y.left = element_text(color = "#244D7F"),
         axis.title.y.right = element_text(color = "#256D3D")) +
  annotate("text", x = Inf, y = Inf, 
           label = "Spearman's R=0.0851",
           hjust = 2.2, vjust = 1.5, 
           size = 3.5)

plot(mirror_plot_corr)
```

Mirror bar plot with the Library size (top - blue) and Sample Weight (bottom - green) per sample. A correlation test by Spearman's method reveals no significant correlation between the two variables. 

The mirror plot displays no observable correlation between library size and sample weight. The Spearman's correlation test provides no significant results on the correlation between library size of the samples and sample weight with a $\rho$ = 0.08509 (very close to 0), and a p-value = 0.3514. 

In conclusion, it is not necessary to normalize the counts of sequencing (library size) by the sample weight. 


## Diversity

### Alpha diversity

**Alpha-diversity** is described as the observed diversity of samples within a sample. [@walters2020]. There are 2 parameters that characterize alpha diversity: 
* Richness: number of taxa (OTUs) observed within a community. *Chao1* or *ACE* measurements. 
* Evenness: relative abundances of the taxa in a community, over all different species. Related to dominance. *Simpson* and *Shannon* measurements.

The analysis of the alpha-diversity aids to understand how microbial communities vary across different conditions.

In this case, we observe the Chao1 and ACE evaluations to plot richness, and Shannon and Simpson analysis to measure alpha evenness.
Including Kruskal-Wallis statistical test to validate if there are significant differences in the alpha diversity comparisons.

```{r rarefying data, echo=FALSE, message=FALSE, warning=FALSE}
#Preparing the rarefied data for further analysis of alpha diversities with Shannon Index

###Rarefy at the minimum sample depth in the dataset
ps.rare <- rarefy_even_depth(ps_clean, rngseed=1, sample.size=(sort(sample_sums(ps_clean))[2]), replace=F) # Sample FF24 is removed because it has 2 reads. FF16 is selected as sample with minimum library size (278 reads). 

ps.rare        ### phyloseq-class experiment-level object
                       ### otu_table()   OTU Table:         [ 24 taxa and 121 samples ]
                       ### sample_data() Sample Data:       [ 121 samples by 6 sample variables ]
                       ### tax_table()   Taxonomy Table:    [ 24 taxa by 7 taxonomic ranks ]
#121 samples --> FF24 has been removed

sample_sums(ps.rare)

#Let's do the analysis:
alpha <- as.data.frame(estimate_richness(ps.rare))
alpha
# Merging alpha with ps_clean
rownames(alpha)
rownames(ps_clean@sam_data)

alpha_meta <- merge(alpha, ps_clean@sam_data, by="row.names", all.y =FALSE)

```

```{r alpha diversity richness , echo=FALSE, warning=FALSE}
ps_clean@sam_data$Group <- as.factor(ps_clean@sam_data$Group)

plot_richness(ps.rare, x="Group", measures=c("Observed", "Chao1", "ACE")) + 
  geom_boxplot(aes(fill=Group), alpha=0.5, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.4) +
  facet_wrap(~variable, nrow = 1) +              
  ggtitle("Alpha Diversity Analysis: Richness") +
  theme_minimal() +  
  stat_compare_means(paired=FALSE) +
  theme(strip.text = element_text(size = 14, face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, size=rel(1))) +
  scale_fill_manual(values = colors_sam)

```

Box plots with the distribution of the Alpha diversity measure among Richness indexes, comparing the three groups of samples: Control (red), normal_paired (green) or tumoral sample (blue). The Alpha diversity richness is measured according to the Chao1 and ACE indexes. The Kruskal-Wallis statistical test compared alpha diversities between groups.

No significant differences in the alpha diversity measurements between groups. Kruskal-Wallis significance value: Observed(p = 0.68), Chao1 (p=0.68), ACE (p=0.92).

Simpson's Index measures the probability that two individuals randomly selected from a sample will belong to the same species (or some category other than species). 

```{r alpha diversity evenness simpson, echo=FALSE}
#Evenness Simpson index
plot_richness(ps.rare, x="Group", measures= "Simpson") + 
  geom_boxplot(aes(fill=Group), alpha=0.5, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.4) +
  facet_wrap(~variable, nrow = 1) +              
  coord_cartesian(ylim = c(0, 1.1)) +
  ggtitle("Alpha Diversity Analysis: Simpson Evenness") +
  theme_minimal() +  
  stat_compare_means(comparisons = list(c("Adjacent", "Control"), c("Control", "Tumor"), c("Adjacent", "Tumor")),
    paired=FALSE, label.y = c(0.80, 0.9, 1 ), label = "p.format") +
  theme(strip.text = element_text(size = 14, face = "bold")) +
  scale_fill_manual(values = colors_sam) + ylab ( "Simpson Index")
```

Box plot with the distribution of the Alpha diversity measure among the Simpson Evenness index comparing the three groups of samples: Control (red), normal_paired (green) or tumoral sample (blue). The comparison of the alpha diversity Simpson richness between groups is tested with the Kruskal-Wallis test.

Significant differences in the Simpson Diversity Index, which evaluates the evenness of the species assignment to the samples. 

```{r shannon index with rarefied data, echo=FALSE, warning=FALSE, message=FALSE}
# Estimate richness using estimate_richness function
alpha<-as.data.frame(estimate_richness(ps.rare))
# Merge alpha-diversity table and metadata from ps_bac object
alpha_meta<-merge(alpha,ps_clean@sam_data,by="row.names", all.x = TRUE, all.y =FALSE )
  
# Plot Shannon index
plot_richness(ps.rare, x = "Group", measures = "Shannon") + 
  geom_boxplot(aes(fill = Group), alpha = 0.5, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.4) +
  facet_wrap(~variable, nrow = 1) +              
  coord_cartesian(ylim = c(0, 1.6)) +
  ggtitle("Alpha Diversity Analysis: Shannon Evenness") +
  theme_minimal() +  
  stat_compare_means(comparisons = list(c("Adjacent", "Control"), c("Control", "Tumor"), c("Adjacent", "Tumor")), 
                     paired = FALSE,
                     label = "p.adj",
                     p.adjust.method = "fdr",
                     aes(label = after_stat(
                       ifelse(p.format < 0.001, paste0("p=", signif(p.format, 3), "  ***"),
                       ifelse(p.format < 0.01,  paste0("p=", signif(p.format, 3), "  **"),
                       ifelse(p.format < 0.05,  paste0("p=", signif(p.format, 3), "  *"),
                                         paste0("p=", signif(p.format, 2), " (ns)")))))), 
                     label.y = c(1.30, 1.40, 1.53)) +
  theme(strip.text = element_text(size = 14, face = "bold")) +
  scale_fill_manual(values = colors_sam) +
  ylab ("Shannon Index")
```

Box plot with the distribution of the Alpha diversity measure among the Shannon Evenness index comparing the three groups of samples: Control (red), normal_paired (green) or tumoral sample (blue). The comparison of the alpha diversity Shannon richness between pairs of groups is tested with the non-parametric Wilcoxon test.

As calculated with the Kruskal-Wallis statistical approach, there are significant differences in the alpha diversity Shannon evenness measure across groups of samples: p-value = 0.029. The Wilcoxon test provides a statistical approach regarding statistica ldifferences between pairs of groups. 


### Beta diversity

```{r beta diversity general, echo=FALSE, warning=FALSE}
# Beta diversity -- Bray Curtis PCoA #
# Perform PCoA ordination analysis on Bray-Curtis distances 
  bray_pcoa_all_b <- ordinate(physeq = ps.rare, method = "PCoA", distance = "bray")

# Plot PCoA 
  plot_ordination(physeq = ps.rare, ordination = bray_pcoa_all_b,
    color = "Group", shape = "Sex") + 
    scale_color_manual(values = colors_sam) +
    geom_point(size = 4)+ stat_ellipse(aes(group = Group), level = 0.95) +
    theme_bw() + ggtitle ("Beta diversity: Bray Curtis PCoA")

  
  # Estimate statistical differences using PERMANOVA - ALL 
  perma_bray_all_f <- phyloseq::distance(ps.rare, method = "bray")
  sampledf_all_f <- data.frame(sample_data(ps.rare))
  adonis2(perma_bray_all_f ~ Group + Sex + scale(Age), data = sampledf_all_f, paired=FALSE) ## p-value = 0.012 *
  adonis2(perma_bray_all_f ~ Group, data = sampledf_all_f, paired=FALSE) ## p-value =  0.007 **
  adonis2(perma_bray_all_f ~ Sex, data = sampledf_all_f, paired=FALSE) ## p-value = 0.113
  adonis2(perma_bray_all_f ~ scale(Age), data = sampledf_all_f, paired=FALSE) ## p-value = 0.272

  
#   Control vs Tumor
   sampledf_ct <- sampledf_all_f[sampledf_all_f$Group %in% c("Control", "Tumor"), ]
   perma_bray_ct <- phyloseq::distance(prune_samples(sampledf_ct$FF_ID, ps.rare), method = "bray")
   adonis2(perma_bray_ct ~ Group + Sex + scale(Age), data = sampledf_ct, paired=FALSE) ## pval = 0.011 *
   adonis2(perma_bray_ct ~ Group, data = sampledf_ct, paired=FALSE) ## pval = 0.001 ***
   adonis2(perma_bray_ct ~ Sex , data = sampledf_ct, paired=FALSE) ## pval = 0.242
   adonis2(perma_bray_ct ~ scale(Age), data = sampledf_ct, paired=FALSE) ## pval = 0.251
   
   
#  Control vs Adjacent
   sampledf_ca <- sampledf_all_f[sampledf_all_f$Group %in% c("Control", "Adjacent"), ]
   perma_bray_ca <- phyloseq::distance(prune_samples(sampledf_ca$FF_ID, ps.rare), method = "bray")
   adonis2(perma_bray_ca ~ Group + Sex + scale(Age), data = sampledf_ca, paired=FALSE) ## pval = 0.028 *
   adonis2(perma_bray_ca ~ Group, data = sampledf_ca, paired=FALSE) ## pval = 0.021 *
   adonis2(perma_bray_ca ~ Sex , data = sampledf_ca, paired=FALSE) ## pval = 0.387
   adonis2(perma_bray_ca ~ scale(Age), data = sampledf_ca, paired=FALSE) ## pval = 0.257
   
   
#  Tumor vs Adjacent
   sampledf_ta <- sampledf_all_f[sampledf_all_f$Group %in% c("Tumor", "Adjacent"), ]
   perma_bray_ta <- phyloseq::distance(prune_samples(sampledf_ta$FF_ID, ps.rare), method = "bray")
   adonis2(perma_bray_ta ~ Group + Sex + scale(Age), data = sampledf_ta, paired=FALSE) ## pval = 0.229
   adonis2(perma_bray_ta ~ Group, data = sampledf_ta, paired=FALSE) ## pval = 0.307
   adonis2(perma_bray_ta ~ Sex , data = sampledf_ta, paired = FALSE) ## pval = 0.076
   adonis2(perma_bray_ta ~ scale(Age), data = sampledf_ta, paired= FALSE) ## pval = 0.287

```


## Differential Abundance Analysis

### Species Level

```{r all vs all, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}

ps_clean@sam_data$Age_scaled <- scale(ps_clean@sam_data$Age)
ps_clean 

        # otu_table()   OTU Table:         [ 32 taxa and 122 samples ]
        # sample_data() Sample Data:       [ 122 samples by 7 sample variables ]
        # tax_table()   Taxonomy Table:    [ 32 taxa by 7 taxonomic ranks ]

ps_clean_RA <- transform_sample_counts(ps_clean, function(x) x/sum(x))

spp_all <- tax_glom(ps_clean_RA, taxrank= "Species", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 14 taxa and 122 samples ]
        # sample_data() Sample Data:       [ 122 samples by 7 sample variables ]
        # tax_table()   Taxonomy Table:    [ 14 taxa by 7 taxonomic ranks ]

spp_melt_all<-psmelt(prune_taxa((names(sort(taxa_sums(spp_all), decreasing = TRUE))), spp_all))

# Plot composition at the spp level
  ggplot(spp_melt_all, aes(x=Sample,y=(Abundance),fill=Species))+ 
    geom_bar(aes(fill=Species), stat="identity", position="fill")+theme_bw()+
    theme(text = element_text(size=12))+
    scale_fill_manual(values=c("antiquewhite3", "bisque1", "brown", "cadetblue1", "coral", "darkolivegreen",  "darkolivegreen3", "darkolivegreen1","darkgoldenrod2", "gold", "deepskyblue3", "darkorchid1", "khaki1", "lightblue1"))+
    facet_wrap( ~ Group, scales="free_x")+
    theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
    scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
    ylab("Relative abundance")+xlab("Samples") +
    theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1)) + 
    ggtitle ("Differential Abundance Analysis at Species Level")

### Limma voom
daa_limma_all <- run_limma_voom(ps_clean_RA,
  group = "Group",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Species",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_all@marker_table ### NULL 

```


### Genus Level

```{r all vs all genus, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}

genus_all <- tax_glom(ps_clean_RA, taxrank= "Genus", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 21 taxa and 122 samples ]
        # sample_data() Sample Data:       [ 122 samples by 7 sample variables ]
        # tax_table()   Taxonomy Table:    [ 21 taxa by 7 taxonomic ranks ]

genus_melt_all<-psmelt(prune_taxa((names(sort(taxa_sums(genus_all), decreasing = TRUE))), genus_all))

  ggplot(genus_melt_all, aes(x=Sample,y=Abundance,fill=Genus))+ 
    geom_bar(aes(fill=Genus), stat="identity", position="fill")+theme_bw()+
    theme(text = element_text(size=12))+
    scale_fill_manual(values=c("antiquewhite3", "aquamarine3", "bisque1", "brown", "cadetblue1", "coral", "darkolivegreen3",  "darkolivegreen1", "darkolivegreen",  "darkgoldenrod2", "gold", "firebrick1", "dodgerblue", "deepskyblue3", "darkorchid1", "khaki1", "lightblue1", "lightsalmon1", "maroon1", "pink", "purple3", "snow2", "yellow1"))+
    facet_wrap( ~ Group, scales="free_x")+
    theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
    scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
    ylab("Relative abundance")+xlab("Samples") +
     theme (legend.position = "right",
         legend.text = element_text(size = 7), 
         legend.title = element_text(size = 8), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1)) + 
    ggtitle("Differential Abundance Analysis at Genus Level")

### Limma voom
daa_limma_all_genus <- run_limma_voom(ps_clean_RA,
  group = "Group",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Genus",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_all_genus@marker_table ### NULL 
```



### Family Level

```{r all vs all fam, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}
fam_all <- tax_glom(ps_clean_RA, taxrank= "Family", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 18 taxa and 122 samples ]
        # sample_data() Sample Data:       [ 122 samples by 7 sample variables ]
        # tax_table()   Taxonomy Table:    [ 18 taxa by 7 taxonomic ranks ]

fam_melt_all<-psmelt(prune_taxa((names(sort(taxa_sums(fam_all), decreasing = TRUE))), fam_all))

# Plot composition at the family level
  ggplot(fam_melt_all, aes(x=Sample,y=Abundance,fill=Family))+ 
    geom_bar(aes(fill=Family), stat="identity", position="fill")+theme_bw()+
    theme(text = element_text(size=12))+
    scale_fill_manual(values=c("antiquewhite3", "aquamarine3", "bisque1", "brown", "cadetblue1", "coral", "darkolivegreen", "darkgoldenrod2", "gold", "firebrick1", "dodgerblue", "darkolivegreen1", "darkolivegreen3", "deepskyblue3", "darkorchid1", "khaki1", "lightblue1", "lightsalmon1", "maroon1", "pink", "purple3", "snow2", "yellow1"))+
    facet_wrap( ~ Group, scales="free_x")+
    theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
    scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
    ylab("Relative abundance")+xlab("Samples") +
     theme (legend.position = "right",
         legend.text = element_text(size = 7), 
         legend.title = element_text(size = 8), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1)) +
    ggtitle ("Differential Abundance Analysis at Family Level")

### Limma voom
daa_limma_all_fam <- run_limma_voom(ps_clean_RA,
  group = "Group",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Family",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_all_fam@marker_table ### NULL
```


### Order Level

```{r all vs all order, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}
ord_all <- tax_glom(ps_clean_RA, taxrank= "Order", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 16 taxa and 122 samples ]
        # sample_data() Sample Data:       [ 122 samples by 7 sample variables ]
        # tax_table()   Taxonomy Table:    [ 16 taxa by 7 taxonomic ranks ]

ord_melt_all<-psmelt(prune_taxa((names(sort(taxa_sums(ord_all), decreasing = TRUE))), ord_all))

# Plot composition at the order level
set.seed(789)
  ggplot(ord_melt_all, aes(x=Sample,y=Abundance,fill=Order))+ 
    geom_bar(aes(fill=Order), stat="identity", position="fill")+theme_bw()+
    theme(text = element_text(size=12))+
    scale_fill_manual(values=c("antiquewhite3", "aquamarine3", "bisque1", "brown", "cadetblue1", "coral", "darkolivegreen", "darkolivegreen1", "darkolivegreen3", "darkgoldenrod2", "gold", "firebrick1", "dodgerblue", "deepskyblue3", "darkorchid1", "khaki1", "lightblue1", "lightsalmon1", "maroon1"))+
    facet_wrap( ~ Group, scales="free_x")+
    theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
    scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
    ylab("Relative abundance")+xlab("Samples") + ggtitle("Differential Abundance Analysis at Order Level") +
     theme (legend.position = "right",
         legend.text = element_text(size = 8), 
         legend.title = element_text(size = 9), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1))

### Limma voom
daa_limma_all_ord <- run_limma_voom(ps_clean_RA,
  group = "Group",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Order",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_all_ord@marker_table ### Methanobacteriales
```


### Class Level

```{r all vs all order, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}
class_all <- tax_glom(ps_clean_RA, taxrank= "Class", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 13 taxa and 122 samples ]
        # sample_data() Sample Data:       [ 122 samples by 7 sample variables ]
        # tax_table()   Taxonomy Table:    [ 13 taxa by 7 taxonomic ranks ]

class_melt_all<-psmelt(prune_taxa((names(sort(taxa_sums(class_all), decreasing = TRUE))), class_all))

# Plot composition at the family level
  ggplot(class_melt_all, aes(x=Sample,y=Abundance,fill=Class))+ 
    geom_bar(aes(fill=Class), stat="identity", position="fill")+theme_bw()+
    theme(text = element_text(size=12))+
    scale_fill_manual(values=c("gold", "aquamarine3", "bisque1", "darkolivegreen3", "firebrick1", "darkgoldenrod2", "darkolivegreen1" ,  "darkolivegreen", "dodgerblue", "maroon1", "deepskyblue3", "darkorchid1", "khaki1", "lightblue1", "lightsalmon1" ))+
    facet_wrap( ~ Group, scales="free_x")+
    theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
    scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
    ylab("Relative abundance")+xlab("Samples") +
     theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1)) +
    ggtitle("Differential Abundance Analysis at Class Level")

### Limma voom
daa_limma_all_class <- run_limma_voom(ps_clean_RA,
  group = "Group",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Class",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_all_class@marker_table ### Methanobacteria
```


### Phylum Level

```{r all vs all order, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}
phylum_all <- tax_glom(ps_clean_RA, taxrank= "Phylum", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 8 taxa and 122 samples ]
        # sample_data() Sample Data:       [ 122 samples by 7 sample variables ]
        # tax_table()   Taxonomy Table:    [ 8 taxa by 7 taxonomic ranks ]

phylum_melt_all<-psmelt(prune_taxa((names(sort(taxa_sums(phylum_all), decreasing = TRUE))), phylum_all))

# Plot composition at the family level
  ggplot(phylum_melt_all, aes(x=Sample,y=Abundance,fill=Phylum))+ 
    geom_bar(aes(fill=Phylum), stat="identity", position="fill")+theme_bw()+
    theme(text = element_text(size=12))+
    scale_fill_manual(values=c("darkolivegreen3", "darkgoldenrod2",  "firebrick1", "darkolivegreen", "gold",  "dodgerblue", "lightblue1", "maroon1", "khaki1", "lightsalmon1"))+
    facet_wrap( ~ Group, scales="free_x")+
    theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
    scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
    ylab("Relative abundance")+xlab("Samples") +
     theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1)) +
    ggtitle("Differential Abundance Analysis at Phylum Level")

### Limma voom
daa_limma_all_phylum <- run_limma_voom(ps_clean_RA,
  group = "Group",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Phylum",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_all_phylum@marker_table ### Methanobacteriota 
```


# Interaction

## Multiple Factor Analysis


Multiple factor analysis (MFA, Pagès et al. 2002) analyzes observations described by several “blocks" or sets of variables, which contain multiple features. MFA seeks the common structures present in all or some of these sets: it is a computational method for discovering the principal sources of variation in multi‐omics data sets. [@argelaguet2018]. MFA is performed in two steps. First a principal component analysis (PCA) is performed on each data set, which is then “normalized” by dividing all of its elements by the square root of the first eigenvalue obtained from its PCA. Second, the normalized data sets are merged to form a unique matrix and a global PCA is performed on this matrix. The goal of MFA is to integrate different groups of variables describing the same observations. (H. Abdi & D. Valentin, 2007).

The package `FactoMineR` (<http://factominer.free.fr/>) was developed to perform Multiple Factor Analysis in R. In this study, the first PCA is performed in each block of omics data (gene expression data, and microbiome/metagenomics) along with the type of sample (Controls, Adjacent or Tumor), which are subsequently normalized, and then a global PCA step is applied.

### MFA at order level

```{r Preparing MFA, echo=TRUE, message=FALSE, warning=FALSE, results = 'hide'}
# MFA:
# The samples must be on the rows and the columns will be the blocks. 

# GROUP SAMPLE:
mfa_group <- metadata_final[, colnames(metadata_final) %in% c("FF_ID", "Group")]
mfa_group$Group <- as.factor(mfa_group$Group)
rownames(mfa_group) <- mfa_group$FF_ID    ## 124 samples

# METADATA:
mfa_metadata <- metadata_final[, colnames(metadata_final) %in% c("FF_ID", "Sex", "Hospital", "Age")]
rownames(mfa_metadata) <- metadata_final$FF_ID
mfa_metadata$Sex <- as.factor(mfa_metadata$Sex)
mfa_metadata$Hospital <- as.factor(mfa_metadata$Hospital)
mfa_metadata <- mfa_metadata[, !colnames(mfa_metadata) %in% c("FF_ID")]  ## 124 samples

# GENE EXPRESSION 
### Gene expression Normalized Data: 
rna_n <- read.csv("/set/to/working/directory/normalized_counts.csv", row.names=1)
## Standarizing gene symbols
rna_n$Symbol <- mapIds(org.Hs.eg.db, keys = rownames(rna_n), keytype = "ENSEMBL", column = "SYMBOL")
genes <- rna_n$Symbol
genes.u <- unique(genes) #13542
rna_n.f <- rna_n[!duplicated(rna_n$Symbol), ]  #13542
rna_n.f <- rna_n.f[!is.na(rna_n.f$Symbol), ]
rownames(rna_n.f) <- rna_n.f$Symbol
rna_n.f <- rna_n.f[, !colnames(rna_n.f) %in% c("Symbol")]
rna_df <- as.data.frame(rna_n.f) 
### This data is already normalized and log2 transformed, filtered by low coefficient of variation and in cpms. 
### We gotta put samples on the rows and genes on the columns

rna_dft <- as.data.frame(t(rna_df))   ### 13542 genes (columns)
mfa_rna <- rna_dft   ### 124 samples (rows) and 13542 columns (genes)


### MICROBIOME DATA
phyloseq_microbiome <- readRDS("/set/to/working/directory/ps_clean.rds")
ord_phyloseq_microbiome <- tax_glom(phyloseq_microbiome, taxrank= "Order", NArm = TRUE)
order_melt_microb <-psmelt(prune_taxa((names(sort(taxa_sums(ord_phyloseq_microbiome), decreasing = TRUE))), ord_phyloseq_microbiome))
order_abundance <- order_melt_microb[, colnames(order_melt_microb) %in% c("Sample", "Order", "Abundance")]

ord_otu_table <- order_abundance %>%
  pivot_wider(names_from = Order, values_from = Abundance ) %>% as.data.frame()
rownames(ord_otu_table) <- ord_otu_table$Sample
ord_otu_table <- ord_otu_table[, !(names(ord_otu_table) %in% "Sample")]

ord_otu_table_log <- log(ord_otu_table +1)  ### Log transform microbiome data

mfa_otu_ord <- ord_otu_table_log  ### 122 samples for 16 taxa at order level


### MFA dimensions:
n_group <- 1
n_rna <- ncol(mfa_rna)
n_microb_ord <- ncol(mfa_otu_ord)
n_total <- n_group + n_rna + n_microb_ord   ### 13559 columns


### MFA:
#Building the dataframe with all the features:Making sure that the row names are in the same order
mfa_group <- mfa_group[rownames(mfa_group) %in% rownames(mfa_otu_ord), ]  ## 122 samples
mfa_rna <- mfa_rna[rownames(mfa_rna) %in% rownames(mfa_otu_ord), ]  ## 122 samples

mfa_otu_ord <- mfa_otu_ord[match(rownames(mfa_rna), rownames(mfa_otu_ord)), ]
mfa_group <- mfa_group[match(rownames(mfa_rna), rownames(mfa_group)), ]
identical(rownames(mfa_rna), rownames(mfa_otu_ord))  ### TRUE
identical(rownames(mfa_rna), rownames(mfa_group)) ### TRUE

mfa_df_f <- data.frame(mfa_group[,2], mfa_rna, mfa_otu_ord , check.names = FALSE)
colnames(mfa_df_f)[1] <- "Group"

dim(mfa_df_f) ### 122 rows and 13559 columns

#write.csv(mfa_df_f, "/set/to/working/directory/MFA_df_ALL_ORDER.csv")


### MFA:
# Building MFA:
mfa_build_ord = MFA(mfa_df_f, group=c(n_group, n_rna, n_microb_ord), 
               type=c(rep("n", 1),rep("c",2)), ncp=3, 
               name.group=c("Group", "mRNA","Ord_Microbiome"),
               graph = TRUE) 

### Dim 1 = 25.4%
### Dim 2 = 15.3%
fviz_mfa_ind(mfa_build_ord, choix= "ind", habillage = "Group", invisible = "quali", geom = "point", addEllipses = TRUE, palette = c("#8DBBDC", "#358747", "#C81518"))


mfa_build_ord_dim3 = MFA(mfa_df_f, group=c(n_group, n_rna, n_microb_ord), axes = c(1,3), 
               type=c(rep("n", 1),rep("c",2)), ncp=3, 
               name.group=c("Group", "mRNA","Ord_Microbiome"),
               graph = TRUE) 
### Dim 1 = 25.4%
### Dim 3 = 13.28%
fviz_mfa_ind(mfa_build_ord_dim3, choix= "ind", habillage = "Group", invisible = "quali", geom = "point", addEllipses = TRUE, palette = c("#8DBBDC", "#358747", "#C81518"), axes = c(1, 3))



### ELBOW PLOT
fviz_screeplot(mfa_build_ord)

```


```{r}
mfa_build_ord$group$coord

#                     Dim.1      Dim.2      Dim.3
# Group          0.91363395 0.66578741 0.32359202
# mRNA           0.90628265 0.09013838 0.06257582
# Ord_Microbiome 0.07925074 0.38583044 0.60781768

mfa_build_ord$group$contrib
#                   Dim.1     Dim.2     Dim.3
# Group          48.10708 58.312571 32.555003
# mRNA           47.72000  7.894713  6.295446
# Ord_Microbiome  4.17292 33.792716 61.149551


mfa_build_ord$separate.analyses$Ord_Microbiome$var$coord


fviz_pca_var(mfa_build_ord$separate.analyses$Ord_Microbiome, repel = TRUE, geom = c("point", "text"), labelsize = 3)

p <- fviz_mfa_ind(mfa_build_ord, choix= "ind", habillage = "Group", invisible = "quali", geom = "point", addEllipses = TRUE, palette = c("#8DBBDC", "#358747", "#C81518"))
coords_ord <- as.data.frame(mfa_build_ord$quanti.var$coord[rownames(mfa_build_ord$quanti.var$coord) %in% colnames(mfa_otu_ord), ])
coords_ord$feature <- rownames(coords_ord)

p +  geom_point(data = coords_ord, aes(x = Dim.1, y = Dim.2), color = "black", size = 2, shape = 17) +
  geom_text_repel(data = coords_ord, aes(x = Dim.1, y = Dim.2, label = feature), size = 3, color = "black")


features_to_label <- c("Peptostreptococcales", "Methanobacteriales", "Rickettsiales")
coords_ord_subset <- coords_ord[coords_ord$feature %in% features_to_label, ]
p + geom_point(data = coords_ord, aes(x = Dim.1, y = Dim.2), color = "black", size = 2, shape = 17) +
  geom_text_repel(data = coords_ord_subset, 
                  aes(x = Dim.1, y = Dim.2, label = feature), 
                  size = 3, color = "black")




p_3 <- fviz_mfa_ind(mfa_build_ord_dim3, choix= "ind", habillage = "Group", invisible = "quali", geom = "point", addEllipses = TRUE, palette = c("#8DBBDC", "#358747", "#C81518"), axes = c(1, 3))
coords_ord3 <- as.data.frame(mfa_build_ord_dim3$quanti.var$coord[rownames(mfa_build_ord_dim3$quanti.var$coord) %in% colnames(mfa_otu_ord), ])
coords_ord3$feature <- rownames(coords_ord3)

p_3 +  geom_point(data = coords_ord3, aes(x = Dim.1, y = Dim.3), color = "black", size = 2, shape = 17) +
  geom_text_repel(data = coords_ord3, aes(x = Dim.1, y = Dim.3, label = feature), size = 3, color = "black")


features_to_label <- c("Peptostreptococcales", "Methanobacteriales", "Rickettsiales")
coords_ord_subset3 <- coords_ord3[coords_ord3$feature %in% features_to_label, ]
p_3 + geom_point(data = coords_ord3, aes(x = Dim.1, y = Dim.3), color = "black", size = 2, shape = 17) +
  geom_text_repel(data = coords_ord_subset3, 
                  aes(x = Dim.1, y = Dim.3, label = feature), 
                  size = 3, color = "black")


```



```{r}
### Genetic factors associated to the microbial signatures:

mfa_build_ord$group$coord
#                     Dim.1      Dim.2      Dim.3
# Group          0.91363395 0.66578741 0.32359202
# mRNA           0.90628265 0.09013838 0.06257582
# Ord_Microbiome 0.07925074 0.38583044 0.60781768
#write.csv(as.data.frame(mfa_build_ord$group$coord), "/set/to/working/directory/Res1_ALL.csv")

mfa_build_ord$group$contrib
#                   Dim.1     Dim.2     Dim.3
# Group          48.10708 58.312571 32.555003
# mRNA           47.72000  7.894713  6.295446
# Ord_Microbiome  4.17292 33.792716 61.149551
#write.csv(as.data.frame(mfa_build_ord$group$contrib), "/set/to/working/directory/Res2_ALL.csv")

mfa_build_ord$group$RV
#                     Group       mRNA Ord_Microbiome       MFA
# Group          1.00000000 0.48853031     0.03683511 0.7843142
# mRNA           0.48853031 1.00000000     0.07861657 0.7475912
# Ord_Microbiome 0.03683511 0.07861657     1.00000000 0.5151916
# MFA            0.78431422 0.74759118     0.51519164 1.0000000
#write.csv(as.data.frame(mfa_build_ord$group$RV), "/set/to/working/directory/Res3_ALL.csv")
  
mfa_build_ord$group$correlation

# dimdesc(mfa_build_ord)$Dim.1$quanti[rownames(dimdesc(mfa_build_ord)$Dim.1$quanti) =="Peptostreptococcales", ]
# dimdesc(mfa_build_ord)$Dim.2$quanti[rownames(dimdesc(mfa_build_ord)$Dim.2$quanti) =="Peptostreptococcales", ]
# dimdesc(mfa_build_ord)$Dim.3$quanti[rownames(dimdesc(mfa_build_ord)$Dim.3$quanti) =="Peptostreptococcales", ]
# 
# dimdesc(mfa_build_ord)$Dim.1$quanti[rownames(dimdesc(mfa_build_ord)$Dim.1$quanti) =="Rickettsiales", ]
# dimdesc(mfa_build_ord)$Dim.2$quanti[rownames(dimdesc(mfa_build_ord)$Dim.2$quanti) =="Rickettsiales", ]
# dimdesc(mfa_build_ord)$Dim.3$quanti[rownames(dimdesc(mfa_build_ord)$Dim.3$quanti) =="Rickettsiales", ]
# 
# dimdesc(mfa_build_ord)$Dim.1$quanti[rownames(dimdesc(mfa_build_ord)$Dim.1$quanti) =="Methanobacteriales", ]
# dimdesc(mfa_build_ord)$Dim.2$quanti[rownames(dimdesc(mfa_build_ord)$Dim.2$quanti) =="Methanobacteriales", ]
# dimdesc(mfa_build_ord)$Dim.3$quanti[rownames(dimdesc(mfa_build_ord)$Dim.3$quanti) =="Methanobacteriales", ]



coords_1 <- mfa_build_ord$global.pca$var$coord[grep("Peptostreptococcales", rownames(mfa_build_ord$global.pca$var$coord)), ]
#      Dim.1      Dim.2      Dim.3 
# -0.3506665  1.2251635 -1.4730776 
coords_2 <- mfa_build_ord$global.pca$var$coord[grep("Rickettsiales", rownames(mfa_build_ord$global.pca$var$coord)), ]
#      Dim.1      Dim.2      Dim.3 
# 0.2663110  0.6102748 -0.8809983  
coords_3 <- mfa_build_ord$global.pca$var$coord[grep("Methanobacteriales", rownames(mfa_build_ord$global.pca$var$coord)), ]
#      Dim.1      Dim.2      Dim.3 
# -0.3877210 -0.1443307 -0.2466862 


vars.pep <- mfa_build_ord$global.pca$var$coord[
  mfa_build_ord$global.pca$var$coord[, "Dim.1"] >= (coords_1[1] - 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.1"] <= (coords_1[1] + 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.2"] >= (coords_1[2] - 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.2"] <= (coords_1[2] + 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.3"] >= (coords_1[3] - 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.3"] <= (coords_1[3] + 0.15) , ]

vars.pep ### These are the features that have a biggest impact on Peptostreptococcales --> Closest coordinates in the groups representation graph. 
cat("The features that have more impact on the Peptostreptococcales feature:", paste0(rownames(vars.pep)[], sep=","),
 "which are located in closest coordinates in the Global PCA after the Multiple Factor Analysis representation.")



vars.rick <- mfa_build_ord$global.pca$var$coord[
  mfa_build_ord$global.pca$var$coord[, "Dim.1"] >= (coords_2[1] - 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.1"] <= (coords_2[1] + 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.2"] >= (coords_2[2] - 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.2"] <= (coords_2[2] + 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.3"] >= (coords_2[3] - 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.3"] <= (coords_2[3] + 0.15) , ]

vars.rick 
cat("The features that have more impact on the Rickettsiales feature:", paste0(rownames(vars.rick)[-1], sep=","),
 "which are located in closest coordinates in the Global PCA after the Multiple Factor Analysis representation.")




vars.meth <- mfa_build_ord$global.pca$var$coord[
  mfa_build_ord$global.pca$var$coord[, "Dim.1"] >= (coords_3[1] - 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.1"] <= (coords_3[1] + 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.2"] >= (coords_3[2] - 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.2"] <= (coords_3[2] + 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.3"] >= (coords_3[3] - 0.15) &
  mfa_build_ord$global.pca$var$coord[, "Dim.3"] <= (coords_3[3] + 0.15) , ]

vars.meth
cat("The features that have more impact on the Methanobacteriales:", paste0(rownames(vars.meth)[-nrow(vars.meth)], sep=","),
 "which are located in closest coordinates in the Global PCA after the Multiple Factor Analysis representation.")
### DBNDD1, GIPR, ACP3, IL20RA, CFAP61, GSTT2, RAB36, SPEF1, SYTL4, JPH1, HSD17B1, KCNC4, KCNQ4, ARTN, DUSP4, SPATA1, BFSP1, MYO5C, AJUBA, LRRIQ1, KHDC1, TSSK4, TPM1, WDR93, SLC5A2, LRRC46, NBPF3, CIMIP5, MIPOL1, KCTD14, PLEKHG4B, NEIL2, PIK3AP1, CFAP161, CREB3L1, CFAP251, UBXN11, ESYT3, RNF207, DRC7, CLPB, PRKAA2, PLSCR2, UCN, MID1IP1, NLGN4Y, MTCL1, NPAS2, HSFX1, LRG1, SNTB1, PRSS27, CBX2, FGFBP3, VPS37D, FXNP2, CEP295NL, MAPK15, PRR36, SRPK3, CLDN6, SGCZ, NRBP2, CCDC9B, CFAP119, PLEKHG4, TMEM63A, ADAM32, GOLGA6L9, C2CD4A, KCNRG, LINC00862, FOXO6, CFAP95, SNORA7A, TSSK1B, CRYGS, VN1R103P, CSKMT, NPIPA7, LOC124906495, RPL5P18, LOC124909376, LGALS8-AS1, LINC01087, SMARCE1P1, LINC01770, C2CD4D, AGKP1, LOC100996437, MIR663AHG, MYO1B-AS1, RPL23AP74, IL6ST-DT, POLR2J2, ARL17A, UBAC2-AS1, FOSL2-AS1, AK3P3, PRRT3-AS1, COA6-AS1, RPL9P10, MTCYBP3, ELN-AS1, CSPG4BP, DLGAP4-AS1, LOC124904411, KRT8P39, LINC02983, RPL7AP20, LOC101927896, SIX3-AS1, SCIRT, RPL21P10, GPAA1P1, PCDHGC5, RPL34P24, ARHGAP8, PWP2, GSK3B-DT, RPS3AP43, CNTF, RN7SL239P, RN7SL16P, RN7SL775P, RN7SL141P, CFAP57, RPL35P6, OR2AE1, FRG1-DT, TOX4P1, HHIP-AS1, ATP5MGL, HMGN1P15, NUDT16-DT, SNHG21, PARAIL, WWC2-AS2, RTEL1P1, PCDHGA5, PCDHGA6, PCDHGA8, PCDHGB2, KRT18P37, TOLLIP-DT, PSMC1P9, LOC100422382, ARHGEF17-AS1, HSPB9, LINC02193, STAM-DT, LOC105370941, GOLGA8S, PCDHGA9, PCDHGB3, NFE2L1-DT, MIF4GD-DT, MIR3648-2, SYPL1P2, RN7SL49P, DDX55P1, C1orf21-DT, ZBTB8B, LOC124903436, PCDHGB9P, PCDHGB5, FLJ38576, CCAT2, CYP4F30P, PRNCR1, LINC02767


rownames(vars.meth)[rownames(vars.meth) %in% deg_ct$Symbol]
# "SGCZ"   
```





### MFA at spp level

```{r Preparing MFA, echo=TRUE, message=FALSE, warning=FALSE, results = 'hide'}
# MFA:
# The samples must be on the rows and the columns will be the blocks. 

# GROUP SAMPLE:
mfa_group <- metadata_final[, colnames(metadata_final) %in% c("FF_ID", "Group")]
mfa_group$Group <- as.factor(mfa_group$Group)
rownames(mfa_group) <- mfa_group$FF_ID    ## 124 samples

# GENE EXPRESSION 
### Gene expression Normalized Data: 
rna_n <- read.csv("/set/to/working/directory/normalized_counts.csv", row.names=1)
## Standarizing gene symbols
rna_n$Symbol <- mapIds(org.Hs.eg.db, keys = rownames(rna_n), keytype = "ENSEMBL", column = "SYMBOL")
genes <- rna_n$Symbol
genes.u <- unique(genes) #13542
rna_n.f <- rna_n[!duplicated(rna_n$Symbol), ]  #13542
rna_n.f <- rna_n.f[!is.na(rna_n.f$Symbol), ]
rownames(rna_n.f) <- rna_n.f$Symbol
rna_n.f <- rna_n.f[, !colnames(rna_n.f) %in% c("Symbol")]
rna_df <- as.data.frame(rna_n.f) 
### This data is already normalized and log2 transformed, filtered by low coefficient of variation and in cpms. 
### We gotta put samples on the rows and genes on the columns

rna_dft <- as.data.frame(t(rna_df))   ### 13542 genes (columns)
mfa_rna <- rna_dft   ### 124 samples (rows) and 13542 columns (genes)


### MICROBIOME DATA
phyloseq_microbiome <- readRDS("/set/to/working/directory/ps_clean.rds")
spp_phyloseq_microbiome <- tax_glom(phyloseq_microbiome, taxrank= "Species", NArm = TRUE)
spp_melt_microb <-psmelt(prune_taxa((names(sort(taxa_sums(spp_phyloseq_microbiome), decreasing = TRUE))), spp_phyloseq_microbiome))
spp_abundance <- spp_melt_microb[, colnames(spp_melt_microb) %in% c("Sample", "Species", "Abundance")]

spp_otu_table <- spp_abundance %>%
  pivot_wider(names_from = Species, values_from = Abundance ) %>% as.data.frame()
rownames(spp_otu_table) <- spp_otu_table$Sample
spp_otu_table <- spp_otu_table[, !(names(spp_otu_table) %in% "Sample")]
spp_otu_table_log <- log(spp_otu_table + 1)

mfa_otu_spp <- spp_otu_table_log  ### 122 samples for 14 taxa at spp level


### MFA dimensions:
n_group <- 1
n_rna <- ncol(mfa_rna)
n_microb_spp <- ncol(mfa_otu_spp)
n_total <- n_group + n_rna + n_microb_spp   ### 13557 columns


### MFA:
#Building the dataframe with all the features:Making sure that the row names are in the same order
mfa_group <- mfa_group[rownames(mfa_group) %in% rownames(mfa_otu_spp), ]  ## 122 samples
mfa_rna <- mfa_rna[rownames(mfa_rna) %in% rownames(mfa_otu_spp), ]  ## 122 samples

mfa_otu_spp <- mfa_otu_spp[match(rownames(mfa_rna), rownames(mfa_otu_spp)), ]
mfa_group <- mfa_group[match(rownames(mfa_rna), rownames(mfa_group)), ]
identical(rownames(mfa_rna), rownames(mfa_otu_spp))  ### TRUE
identical(rownames(mfa_rna), rownames(mfa_group)) ### TRUE

mfa_df_spp <- data.frame(mfa_group[,2], mfa_rna, mfa_otu_spp , check.names = FALSE)
colnames(mfa_df_spp)[1] <- "Group"

dim(mfa_df_spp) ### 122 rows and 13557 columns
#write.csv(mfa_df_spp, "/set/to/working/directory/MFA_df_ALL_SPECIES.csv")

### MFA:
# Building MFA:
mfa_build_spp = MFA(mfa_df_spp, group=c(n_group, n_rna, n_microb_spp),
               type=c(rep("n", 1),rep("c",2)), ncp=3, 
               name.group=c("Group", "mRNA","Spp_Microbiome"),
               graph = TRUE) 

### PC1 = 27.3%
### PC2 = 16.40%

fviz_mfa_ind(mfa_build_spp, choix= "ind", habillage = "Group", invisible = "quali", geom = "point", addEllipses = TRUE, palette = c("#8DBBDC", "#358747", "#C81518"))

```

```{r}
mfa_build_spp$group$coord
#                     Dim.1      Dim.2      Dim.3
# Group          0.90336252 0.71617609 0.28613040
# mRNA           0.89941780 0.09348436 0.07245561
# Spp_Microbiome 0.09518667 0.33103895 0.61718148

mfa_build_spp$group$contrib
#                    Dim.1     Dim.2     Dim.3
# Group          47.596324 62.783945 29.323625
# mRNA           47.388485  8.195355  7.425499
# Spp_Microbiome  5.015191 29.020700 63.250876


mfa_build_spp$separate.analyses$Spp_Microbiome$var$coord


fviz_pca_var(mfa_build_spp$separate.analyses$Spp_Microbiome, repel = TRUE, geom = c("point", "text"), labelsize = 3)


p_spp <- fviz_mfa_ind(mfa_build_spp, choix= "ind", habillage = "Group", invisible = "quali", geom = "point", addEllipses = TRUE, palette = c("#8DBBDC", "#358747", "#C81518"))
coords_spp <- as.data.frame(mfa_build_spp$quanti.var$coord[rownames(mfa_build_spp$quanti.var$coord) %in% colnames(mfa_otu_spp), ])
coords_spp$feature <- rownames(coords_spp)

p_spp +  geom_point(data = coords_spp, aes(x = Dim.1, y = Dim.2), color = "black", size = 2, shape = 17) +
  geom_text_repel(data = coords_spp, aes(x = Dim.1, y = Dim.2, label = feature), size = 3, color = "black")


spp_to_label <- c("Clostridioides difficile", "Methanobrevibacter smithii") ### Features with coord > 1 in at least 1 dimension
coords_spp_subset <- coords_spp[coords_spp$feature %in% spp_to_label, ]
p_spp + geom_point(data = coords_spp, aes(x = Dim.1, y = Dim.2), color = "black", size = 2, shape = 17) +
  geom_text_repel(data = coords_spp_subset, 
                  aes(x = Dim.1, y = Dim.2, label = feature), 
                  size = 3, color = "black")
```





### Multiple Factor Analysis - PC Subtypes

Multiple Factor analysis only with tumor samples, to associate with Prediction of Bailey's subtypes. 

```{r preparing the tumor data, echo=FALSE}
### Preparing the tumor samples, their prediction of Bailey's signture, and 
Prediction_Bailey <- read.csv("/set/to/working/directory/Prediction_Bailey.csv", row.names=1)
Prediction_Bailey$Samples_ID <- rownames(Prediction_Bailey)
tumorids <- rownames(Prediction_Bailey)

### Prediction of Bailey's 
Pred_Baileys <- Prediction_Bailey[, colnames(Prediction_Bailey) %in% c("PredBailey", "Samples_ID")]
mfa_pred_bailey <- Pred_Baileys  # 53 samples


### Gene Expression Tumor samples
tumor_rna_df <- rna_df[, colnames(rna_df) %in% tumorids] #53 columns = 53 samples, good
tumor_rna_df   ### This data is normalized and log2 transformed, filtered by low coefficient of variation and in cpms. 
               ### We gotta put samples on the rows and genes on the columns
tumor_rna_dft <- as.data.frame(t(tumor_rna_df))
mfa_rna_tumor <- tumor_rna_dft

mfa_rna_tumor <- mfa_rna_tumor [match(rownames(mfa_pred_bailey), rownames(mfa_rna_tumor )), ]
identical(rownames(mfa_pred_bailey), rownames(mfa_rna_tumor)) # TRUE


### Microbiome Tumor Samples - Order tax rank
tumor_otu_df_ord <- ord_otu_table[rownames(ord_otu_table) %in% tumorids, ] ### 53 columns = 53 samples, 16 otus
tumor_otu_df_ord_log <- log(tumor_otu_df_ord + 1)
mfa_otu_tumor_ord <- tumor_otu_df_ord_log 
mfa_otu_tumor_ord  <- mfa_otu_tumor_ord[match(rownames(mfa_rna_tumor), rownames(mfa_otu_tumor_ord )), ]
identical(rownames(mfa_pred_bailey), rownames(mfa_otu_tumor_ord )) # TRUE

# Building MFA:
## Number of features in each block:
n_predBaileys <- 1
n_rna_t <- ncol(mfa_rna_tumor) #13542
n_microb_t <- ncol(mfa_otu_tumor_ord) #16
n_total_t <- n_predBaileys + n_rna_t + n_microb_t # 13559 columns


## Building dataframe with all the features:
mfa_df_tumor_ord <- data.frame(mfa_pred_bailey[, 1], mfa_rna_tumor, mfa_otu_tumor_ord, check.names = FALSE)
colnames(mfa_df_tumor_ord)[1] <- "Pred_Bailey"

dim(mfa_df_tumor_ord)   ### 53 rows = 53 tumor samples
                        ### 13559 columns  = 13559 features
#write.csv(mfa_df_tumor_ord, "/set/to/working/directory/MFA_df_TUMOR_ORDER.csv")

### MFA:
# Building MFA:
mfa_build_tumor_ord = MFA(mfa_df_tumor_ord, group=c(n_predBaileys, n_rna_t, n_microb_t),
               type=c(rep("n", 1),rep("c",2)), ncp=3, 
               name.group=c("Pred_Bailey", "mRNA","Ord_Microbiome"),
               graph = TRUE) 
#### PC1 = 18.74%
#### PC2 = 14.12%

fviz_mfa_ind(mfa_build_tumor_ord, choix= "ind", habillage = "Pred_Bailey", invisible = "quali", geom = "point", addEllipses = TRUE , palette = c("saddlebrown", "red3", "orange", "steelblue"))


# Building MFA:
mfa_build_tumor_ord_3 = MFA(mfa_df_tumor_ord, group=c(n_predBaileys, n_rna_t, n_microb_t), axes = c(1, 3), 
               type=c(rep("n", 1),rep("c",2)), ncp=3, 
               name.group=c("Pred_Bailey", "mRNA","Ord_Microbiome"),
               graph = TRUE) 


fviz_mfa_ind(mfa_build_tumor_ord_3, choix= "corr", habillage = "Pred_Bailey", invisible = "quali", geom = "point", addEllipses = TRUE , palette = c("saddlebrown", "red3", "orange", "steelblue"))


### ELBOW PLOT
fviz_screeplot(mfa_build_tumor_ord)

```



```{r}
k <- fviz_mfa_ind(mfa_build_tumor_ord, choix= "ind", habillage = "Pred_Bailey", invisible = "quali", geom = "point", addEllipses = TRUE, palette = c("saddlebrown", "red3", "orange", "steelblue"))
coords_tum <- as.data.frame(mfa_build_tumor_ord$quanti.var$coord[rownames(mfa_build_tumor_ord$quanti.var$coord) %in% colnames(mfa_otu_ord), ])
coords_tum$feature <- rownames(coords_tum)

k +  geom_point(data = coords_tum, aes(x = Dim.1, y = Dim.2), color = "black", size = 2, shape = 17) +
  geom_text_repel(data = coords_tum, aes(x = Dim.1, y = Dim.2, label = feature), size = 3, color = "black")


features_to_label <- c("Peptostreptococcales", "Methanobacteriales", "Rickettsiales")
coords_tum_subset <- coords_tum[coords_tum$feature %in% features_to_label, ]
k + geom_point(data = coords_tum, aes(x = Dim.1, y = Dim.2), color = "black", size = 2, shape = 17) +
  geom_text_repel(data = coords_tum_subset, 
                  aes(x = Dim.1, y = Dim.2, label = feature), 
                  size = 3, color = "black")


k_3 <- fviz_mfa_ind(mfa_build_tumor_ord_3, choix= "ind", habillage = "Pred_Bailey", invisible = "quali", geom = "point", addEllipses = TRUE, palette = c("saddlebrown", "red3", "orange", "steelblue"), axes = c(1, 3))
coords_tum3 <- as.data.frame(mfa_build_tumor_ord_3$quanti.var$coord[rownames(mfa_build_tumor_ord_3$quanti.var$coord) %in% colnames(mfa_otu_ord), ])
coords_tum3$feature <- rownames(coords_tum3)

k_3 +  geom_point(data = coords_tum3, aes(x = Dim.1, y = Dim.3), color = "black", size = 2, shape = 17) +
  geom_text_repel(data = coords_tum3, aes(x = Dim.1, y = Dim.3, label = feature), size = 3, color = "black")


features_to_label <- c("Peptostreptococcales", "Methanobacteriales", "Rickettsiales")
coords_tum_subset3 <- coords_tum3[coords_tum3$feature %in% features_to_label, ]
k_3 + geom_point(data = coords_tum3, aes(x = Dim.1, y = Dim.3), color = "black", size = 2, shape = 17) +
  geom_text_repel(data = coords_tum_subset3, 
                  aes(x = Dim.1, y = Dim.3, label = feature), 
                  size = 3, color = "black")
```



```{r}

mfa_build_tumor_ord$group$coord
#                    Dim.1      Dim.2     Dim.3
# Pred_Bailey    0.7184982 0.95757410 0.8861146
# mRNA           0.8512283 0.40475485 0.1478320
# Ord_Microbiome 0.2708225 0.02420129 0.1460627
#write.csv(as.data.frame(mfa_build_tumor_ord$group$coord), "/set/to/working/directory/Bailey_1.csv")

mfa_build_tumor_ord$group$contrib
#                   Dim.1     Dim.2    Dim.3
# Pred_Bailey    39.03717 69.062619 75.09387
# mRNA           46.24861 29.191924 12.52804
# Ord_Microbiome 14.71422  1.745457 12.37810
#write.csv(as.data.frame(mfa_build_tumor_ord$group$contrib), "/set/to/working/directory/Bailey_2.csv")

mfa_build_tumor_ord$group$RV
#                Pred_Bailey      mRNA Ord_Microbiome       MFA
# Pred_Bailey     1.00000000 0.4210890     0.02968541 0.7934622
# mRNA            0.42108896 1.0000000     0.18324725 0.7694641
# Ord_Microbiome  0.02968541 0.1832473     1.00000000 0.4812736
# MFA             0.79346219 0.7694641     0.48127362 1.0000000
#write.csv(as.data.frame(mfa_build_tumor_ord$group$RV), "/set/to/working/directory/Bailey_3.csv")
  
mfa_build_tumor_ord$group$correlation

# dimdesc(mfa_build_tumor_ord)$Dim.1$quanti[rownames(dimdesc(mfa_build_tumor_ord)$Dim.1$quanti) =="Peptostreptococcales", ]
# dimdesc(mfa_build_tumor_ord)$Dim.2$quanti[rownames(dimdesc(mfa_build_tumor_ord)$Dim.2$quanti) =="Peptostreptococcales", ]
# dimdesc(mfa_build_tumor_ord)$Dim.3$quanti[rownames(dimdesc(mfa_build_tumor_ord)$Dim.3$quanti) =="Peptostreptococcales", ]
# 
# dimdesc(mfa_build_tumor_ord)$Dim.1$quanti[rownames(dimdesc(mfa_build_tumor_ord)$Dim.1$quanti) =="Rickettsiales", ]
# dimdesc(mfa_build_tumor_ord)$Dim.2$quanti[rownames(dimdesc(mfa_build_tumor_ord)$Dim.2$quanti) =="Rickettsiales", ]
# dimdesc(mfa_build_tumor_ord)$Dim.3$quanti[rownames(dimdesc(mfa_build_tumor_ord)$Dim.3$quanti) =="Rickettsiales", ]
# 
# dimdesc(mfa_build_tumor_ord)$Dim.1$quanti[rownames(dimdesc(mfa_build_tumor_ord)$Dim.1$quanti) =="Methanobacteriales", ]
# dimdesc(mfa_build_tumor_ord)$Dim.2$quanti[rownames(dimdesc(mfa_build_tumor_ord)$Dim.2$quanti) =="Methanobacteriales", ]
# dimdesc(mfa_build_tumor_ord)$Dim.3$quanti[rownames(dimdesc(mfa_build_tumor_ord)$Dim.3$quanti) =="Methanobacteriales", ]



coords_pep_bailey <- mfa_build_tumor_ord$global.pca$var$coord[grep("Peptostreptococcales", rownames(mfa_build_tumor_ord$global.pca$var$coord)), ]
#      Dim.1      Dim.2      Dim.3 
# -1.1489238  0.1146869  0.8004497 


vars.pep_bailey <- mfa_build_tumor_ord$global.pca$var$coord[
  mfa_build_tumor_ord$global.pca$var$coord[, "Dim.1"] >= (coords_pep_bailey[1] - 0.15) &
  mfa_build_tumor_ord$global.pca$var$coord[, "Dim.1"] <= (coords_pep_bailey[1] + 0.15) &
  mfa_build_tumor_ord$global.pca$var$coord[, "Dim.2"] >= (coords_pep_bailey[2] - 0.15) &
  mfa_build_tumor_ord$global.pca$var$coord[, "Dim.2"] <= (coords_pep_bailey[2] + 0.15) &
  mfa_build_tumor_ord$global.pca$var$coord[, "Dim.3"] >= (coords_pep_bailey[3] - 0.15) &
  mfa_build_tumor_ord$global.pca$var$coord[, "Dim.3"] <= (coords_pep_bailey[3] + 0.15) , ]

vars.pep_bailey ### These are the features that have a biggest impact on Peptostreptococcales --> Closest coordinates in the groups representation graph. 
cat("The features that have more impact on the Peptostreptococcales feature are:", paste0(rownames(vars.pep_bailey)[], sep=","),
 "which are located in closest coordinates in the Global PCA after the Multiple Factor Analysis representation.")

```



```{r}
mfa_build_tumor_ord$group$coord
#                    Dim.1      Dim.2     Dim.3
# Pred_Bailey    0.7184982 0.95757410 0.8861146
# mRNA           0.8512283 0.40475485 0.1478320
# Ord_Microbiome 0.2708225 0.02420129 0.1460627

mfa_build_tumor_ord$group$contrib
#                   Dim.1     Dim.2    Dim.3
# Pred_Bailey    39.03717 69.062619 75.09387
# mRNA           46.24861 29.191924 12.52804
# Ord_Microbiome 14.71422  1.745457 12.37810


mfa_build_tumor_ord$separate.analyses$Ord_Microbiome$var$coord


fviz_pca_var(mfa_build_tumor_ord$separate.analyses$Ord_Microbiome, repel = TRUE, geom = c("point", "text"), labelsize = 3)


p_tum_ord <- fviz_mfa_ind(mfa_build_tumor_ord, choix= "ind", habillage = "Pred_Bailey", invisible = "quali", geom = "point", addEllipses = TRUE, palette = c("saddlebrown", "red3", "orange", "steelblue"))
coords_tum_ord <- as.data.frame(mfa_build_tumor_ord$quanti.var$coord[rownames(mfa_build_tumor_ord$quanti.var$coord) %in% colnames(mfa_otu_tumor_ord), ])
coords_tum_ord$feature <- rownames(coords_tum_ord)

p_tum_ord +  geom_point(data = coords_tum_ord, aes(x = Dim.1, y = Dim.2), color = "black", size = 2, shape = 17) +
  geom_text_repel(data = coords_tum_ord, aes(x = Dim.1, y = Dim.2, label = feature), size = 3, color = "black")


tum_ord_to_label <- c("Peptostreptococcales") ### Features with coord > 1 in at least 1 dimension
coords_tum_ord_subset <- coords_tum_ord[coords_tum_ord$feature %in% tum_ord_to_label, ]
p_tum_ord + geom_point(data = coords_tum_ord, aes(x = Dim.1, y = Dim.2), color = "black", size = 2, shape = 17) +
  geom_text_repel(data = coords_tum_ord_subset, 
                  aes(x = Dim.1, y = Dim.2, label = feature), 
                  size = 3, color = "black")

```




## Microbiome Analysis on PC subtypes

### Alpha diversity

```{r}
###Rarefy at the minimum sample depth in the dataset
ps_tumor <- prune_samples(sample_names(ps_clean) %in% ps_clean@sam_data$FF_ID[ps_clean@sam_data$Group == "Tumor"], ps_clean)
ps_tumor@sam_data$Pred_Bailey <- pred_subtypes$PredBailey[match(rownames(ps_tumor@sam_data), pred_subtypes$Samples_ID)] #Including the Predicted Bailey subtype 

ps.rare.tumor <- rarefy_even_depth(ps_tumor, rngseed=1, sample.size=(sort(sample_sums(ps_tumor))), replace=F) 

ps.rare.tumor      ### phyloseq-class experiment-level object
                   ### otu_table()   OTU Table:         [ 22 taxa and 53 samples ]
                   ### sample_data() Sample Data:       [ 53 samples by 8 sample variables ]
                   ### tax_table()   Taxonomy Table:    [ 22 taxa by 7 taxonomic ranks ]
#Let's do the analysis:
alpha.t <- as.data.frame(estimate_richness(ps.rare.tumor))
alpha.t
alpha_meta.t <- merge(alpha.t, ps_tumor@sam_data, by="row.names", all.y =FALSE)

plot_richness(ps.rare.tumor, x="Pred_Bailey", measures=c("Observed", "Chao1", "ACE")) + 
  geom_boxplot(aes(fill=Pred_Bailey), alpha=0.5, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.4) +
  facet_wrap(~variable, nrow = 1) +              
  ggtitle("Alpha Diversity Analysis - Tumor Samples: Richness") +
  theme_minimal() +  
  stat_compare_means(paired=FALSE, size = 2.8) +
  theme(strip.text = element_text(size = 10, face = "bold"), 
        axis.text.x = element_text(angle = 45, hjust = 1, size=rel(1))) +
  scale_fill_manual(values = colors_bailey)

### No significant differences in the alpha diversity measurements between groups. Kruskal-Wallis significance value: Observed(p = 0.94), Chao1 (p=0.94), ACE (p=0.92). 


#Evenness Simpson index
plot_richness(ps.rare.tumor, x="Pred_Bailey", measures= "Simpson") + geom_boxplot(aes(fill=Pred_Bailey), alpha=0.5, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.4) + facet_wrap(~variable, nrow = 1) +              
  coord_cartesian(ylim = c(0, 1.5)) + ggtitle("Alpha Diversity Analysis - Tumor Samples: Simpson Evenness") +
  theme_minimal() +  
  stat_compare_means(comparisons = list(c("ADEX", "Immunogenic"), c("ADEX", "Squamous"), c("ADEX", "Progenitor"), c("Immunogenic", "Squamous"), c("Immunogenic", "Progenitor"), c("Squamous", "Progenitor")),
    paired=FALSE, label.y = c(0.80, 0.9, 1, 1.1, 1.2, 1.3), label = "p.format") +
  theme(strip.text = element_text(size = 14, face = "bold")) +
  scale_fill_manual(values = colors_bailey) + ylab ( "Simpson Index") + xlab ("Predicted PC Subtype")

### No significant differences

# Plot Shannon index
plot_richness(ps.rare.tumor, x="Pred_Bailey", measures = "Shannon") + 
  geom_boxplot(aes(fill = Pred_Bailey), alpha = 0.5, outlier.shape = NA) +  geom_jitter(width = 0.2, alpha = 0.4) +
  facet_wrap(~variable, nrow = 1) + coord_cartesian(ylim = c(0, 2)) +
  ggtitle("Alpha Diversity Analysis - Tumor Samples: Shannon Evenness") +
  theme_minimal() +  
  stat_compare_means(comparisons = list(c("ADEX", "Immunogenic"), c("ADEX", "Squamous"), c("ADEX", "Progenitor"), c("Immunogenic", "Squamous"), c("Immunogenic", "Progenitor"), c("Squamous", "Progenitor")), 
         paired = FALSE, label = "p.adj", p.adjust.method = "fdr", label.y = c(1.30, 1.40, 1.53, 1.67, 1.80, 1.92)) +
  theme(strip.text = element_text(size = 14, face = "bold")) +
  scale_fill_manual(values = colors_bailey) +
  ylab ("Shannon Index") + xlab ("Predicted PC subtype")

### No significant differences

```


### Beta diversity

```{r beta diversity general, echo=FALSE, warning=FALSE}
# Beta diversity 
bray_pcoa_tumor <- ordinate(physeq = ps.rare.tumor, method = "PCoA", distance = "bray")
# Plot PCoA 
plot_ordination(physeq = ps.rare.tumor, ordination = bray_pcoa_tumor,
  color = "Pred_Bailey", shape = "Sex") + scale_color_manual(values = colors_bailey) +
  geom_point(size = 4)+ stat_ellipse(aes(group = Pred_Bailey), level = 0.95) +
  theme_bw() + ggtitle ("Beta diversity - PC subtypes: Bray Curtis PCoA")

# Estimate statistical differences using PERMANOVA - ALL 
perma_bray_tumor <- phyloseq::distance(ps.rare.tumor, method = "bray")
sampledf_tumor <- data.frame(sample_data(ps.rare.tumor))
adonis2(perma_bray_tumor ~ Pred_Bailey + Sex + scale(Age), data = sampledf_tumor, paired=FALSE) ## p-value = 0.588
adonis2(perma_bray_tumor ~ Pred_Bailey, data = sampledf_tumor, paired=FALSE) ## p-value =  0.844
adonis2(perma_bray_tumor ~ Sex, data = sampledf_tumor, paired=FALSE) ## p-value = 0.285
adonis2(perma_bray_tumor ~ scale(Age), data = sampledf_tumor, paired=FALSE) ## p-value = 0.268


comp <- list(c("ADEX", "Immunogenic"), c("ADEX", "Squamous"), c("ADEX", "Progenitor"), c("Immunogenic", "Squamous"), c("Immunogenic", "Progenitor"), c("Squamous", "Progenitor"))

res_betatum <- data.frame ()
for (i in seq_along(comp)) {
  sampledf_comp <- sampledf_tumor[sampledf_tumor$Pred_Bailey %in% comp[[i]], ]
  ps_comp <- prune_samples(rownames(sampledf_comp), ps.rare.tumor)
  perma_bray_tumor <- phyloseq::distance(ps_comp, method = "bray")
  models <- list(
    model1 = adonis2(perma_bray_tumor ~ Pred_Bailey + Sex + scale(Age), data = sampledf_comp),
    model2 = adonis2(perma_bray_tumor ~ Pred_Bailey, data = sampledf_comp),
    model3 = adonis2(perma_bray_tumor ~ Sex, data = sampledf_comp),
    model4 = adonis2(perma_bray_tumor ~ scale(Age), data = sampledf_comp))
  for (m in names(models)) {
    tab <- models[[m]]
    res <- data.frame(
      Comparison = paste(comp[[i]], collapse = " vs "),
      Model = m,
      R2 = tab$R2[1],
      pval = tab$`Pr(>F)`[1])
    res_betatum <- bind_rows(res_betatum, res)
  }
}

res_betatum 
#write.csv(res_betatum, "/set/to/working/directory/beta_tum.csv")

```


### Differential Abundance analaysis of Tumoral Samples 

#### Species Level

```{r all vs all, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}

ps_tumor <- prune_samples(sample_names(ps_clean) %in% ps_clean@sam_data$FF_ID[ps_clean@sam_data$Group == "Tumor"], ps_clean)

ps_tumor@sam_data$Pred_Bailey <- pred_subtypes$PredBailey[match(rownames(ps_tumor@sam_data), pred_subtypes$Samples_ID)] #Including the Predicted Bailey subtype 

ps_tumor@sam_data$Age_scaled <- scale(ps_tumor@sam_data$Age)

ps_tumor  
        # otu_table()   OTU Table:         [ 32 taxa and 53 samples ]
        # sample_data() Sample Data:       [ 53 samples by 8 sample variables ]
        # tax_table()   Taxonomy Table:    [ 32 taxa by 7 taxonomic ranks ]


ps_tumor_RA <- transform_sample_counts(ps_tumor, function(x) x/sum(x))

spp_ps_tum <- tax_glom(ps_tumor_RA, taxrank= "Species", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 14 taxa and 53 samples ]
        # sample_data() Sample Data:       [ 53 samples by 8 sample variables ]
        # tax_table()   Taxonomy Table:    [ 14 taxa by 7 taxonomic ranks ]

spp_melt_tum<-psmelt(prune_taxa((names(sort(taxa_sums(spp_ps_tum), decreasing = TRUE))), spp_ps_tum))

ggplot(spp_melt_tum, aes(x=Sample,y=Abundance,fill=Species))+ 
  geom_bar(aes(fill=Species), stat="identity", position="fill")+theme_bw()+
   theme(text = element_text(size=12))+
   scale_fill_manual(values=c("antiquewhite3", "darkblue", "brown", "coral", "darkolivegreen", "darkgoldenrod4", "darkolivegreen3", "gold", "firebrick1", "dodgerblue", "darkolivegreen1", "deepskyblue3", "darkorchid1", "khaki4", "lightblue1", "pink", "purple3"))+
   facet_wrap( ~ Pred_Bailey, scales="free_x")+
   theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
   scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
   ylab("Relative abundance")+xlab("Tumor Samples") + ggtitle ("Differential Abundance Analysis of PC subtypes at Species Level") +
     theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1))


### Limma voom
daa_limma_tum_spp <- run_limma_voom(ps_tumor_RA,
  group = "Pred_Bailey",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Species",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_tum_spp@marker_table   ### NULL
```


#### Genus Level

```{r all vs all tumor genus, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}

genus_ps_tum <- tax_glom(ps_tumor_RA, taxrank= "Genus", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 21 taxa and 53 samples ]
        # sample_data() Sample Data:       [ 53 samples by 8 sample variables ]
        # tax_table()   Taxonomy Table:    [ 21 taxa by 7 taxonomic ranks ]

genus_melt_tum<-psmelt(prune_taxa((names(sort(taxa_sums(genus_ps_tum), decreasing = TRUE))), genus_ps_tum))

ggplot(genus_melt_tum, aes(x=Sample,y=Abundance,fill=Genus))+ 
  geom_bar(aes(fill=Genus), stat="identity", position="fill")+theme_bw()+
  theme(text = element_text(size=12))+
  scale_fill_manual(values=c("antiquewhite3", "darkblue", "brown", "coral", "darkolivegreen", "darkgoldenrod3", "darkolivegreen3", "gold", "firebrick1", "dodgerblue", "darkolivegreen1", "deepskyblue3", "darkorchid1", "khaki4", "lightblue1", "pink", "purple3", "darkmagenta", "sandybrown", "saddlebrown", "palegoldenrod"))+
   facet_wrap( ~ Pred_Bailey, scales="free_x")+
   theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
   scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
   ylab("Relative abundance")+xlab("Tumor samples") +
     theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1)) +
   ggtitle("Differential Abundance Analysis of PC subtypes at Genus Level")

### Limma voom
daa_limma_tum_genus <- run_limma_voom(ps_tumor_RA,
  group = "Pred_Bailey",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Genus",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_tum_genus@marker_table ### NULL
```



#### Family Level

```{r all vs all fam, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}
fam_ps_tum <- tax_glom(ps_tumor_RA, taxrank= "Family", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 18 taxa and 53 samples ]
        # sample_data() Sample Data:       [ 53 samples by 8 sample variables ]
        # tax_table()   Taxonomy Table:    [ 18 taxa by 7 taxonomic ranks ]

fam_melt_tum<-psmelt(prune_taxa((names(sort(taxa_sums(fam_ps_tum), decreasing = TRUE))), fam_ps_tum))

ggplot(fam_melt_tum, aes(x=Sample,y=Abundance,fill=Family))+ 
  geom_bar(aes(fill=Family), stat="identity", position="fill")+theme_bw()+
  theme(text = element_text(size=12))+
  scale_fill_manual(values=c("antiquewhite3", "darkblue", "brown", "coral", "darkolivegreen", "darkgoldenrod3", "gold", "firebrick1", "dodgerblue", "darkolivegreen1", "deepskyblue3", "darkorchid1", "darkolivegreen3", "khaki4", "lightblue1", "pink", "purple3",  "sandybrown", "darkmagenta", "saddlebrown", "palegoldenrod"))+
   facet_wrap( ~ Pred_Bailey, scales="free_x")+
   theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
   scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
   ylab("Relative abundance")+xlab("Tumor samples") +
     theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1)) + 
  ggtitle("Differential Abundance Analysis of PC subtypes at Family Level")

### Limma voom
daa_limma_tum_fam <- run_limma_voom(ps_tumor_RA,
  group = "Pred_Bailey",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Family",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_tum_fam@marker_table   ###  NULL
```


#### Order Level

```{r all vs all order, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}
ord_ps_tum <- tax_glom(ps_tumor_RA, taxrank= "Order", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 16 taxa and 53 samples ]
        # sample_data() Sample Data:       [ 53 samples by 8 sample variables ]
        # tax_table()   Taxonomy Table:    [ 16 taxa by 7 taxonomic ranks ]

ord_melt_tum<-psmelt(prune_taxa((names(sort(taxa_sums(ord_ps_tum), decreasing = TRUE))), ord_ps_tum))

ggplot(ord_melt_tum, aes(x=Sample,y=Abundance,fill=Order))+ 
  geom_bar(aes(fill=Order), stat="identity", position="fill")+theme_bw()+
  theme(text = element_text(size=12))+
  scale_fill_manual(values=c("antiquewhite3", "darkblue", "brown", "coral", "darkolivegreen", "darkgoldenrod3", "gold", "firebrick1", "darkolivegreen3", "dodgerblue", "darkolivegreen1", "deepskyblue3", "darkorchid1", "khaki4", "lightblue1", "pink", "purple3",  "sandybrown", "darkmagenta", "saddlebrown", "palegoldenrod"))+
   facet_wrap( ~ Pred_Bailey, scales="free_x")+
   theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
   scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
   ylab("Relative abundance")+xlab("Tumor samples") +
     theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1)) + 
   ggtitle("Differential Abundance analysis of PC subtypes at Order Level")

### Limma voom
daa_limma_tum_ord <- run_limma_voom(ps_tumor_RA,
  group = "Pred_Bailey",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Order",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_tum_ord@marker_table   ### NULL

```


#### Class Level

```{r all vs all order, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}
class_ps_tum <- tax_glom(ps_tumor_RA, taxrank= "Class", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 13 taxa and 53 samples ]
        # sample_data() Sample Data:       [ 53 samples by 8 sample variables ]
        # tax_table()   Taxonomy Table:    [ 13 taxa by 7 taxonomic ranks ]

class_melt_tum<-psmelt(prune_taxa((names(sort(taxa_sums(class_ps_tum), decreasing = TRUE))), class_ps_tum))

ggplot(class_melt_tum, aes(x=Sample,y=Abundance,fill=Class))+ 
  geom_bar(aes(fill=Class), stat="identity", position="fill")+theme_bw()+
  theme(text = element_text(size=12))+
  scale_fill_manual(values=c("darkolivegreen1", "antiquewhite3", "darkblue", "darkolivegreen3", "darkolivegreen", "darkgoldenrod3", "gold", "firebrick1",  "coral" , "dodgerblue" , "deepskyblue3", "darkorchid1","brown",  "khaki4", "lightblue1", "pink", "purple3",  "sandybrown", "darkmagenta", "saddlebrown", "palegoldenrod"))+
   facet_wrap( ~ Pred_Bailey, scales="free_x")+
   scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
   theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
   ylab("Relative abundance")+xlab("Tumor samples") +
     theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1)) +
  ggtitle("Differential Abundance analysis of PC subtypes at Class Level")

### Limma voom
daa_limma_tum_class <- run_limma_voom(ps_tumor_RA,
  group = "Pred_Bailey",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Class",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_tum_class@marker_table   ### NULL
```


#### Phylum Level

```{r all vs all order, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}
phylum_ps_tum <- tax_glom(ps_tumor_RA, taxrank= "Phylum", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 8 taxa and 53 samples ]
        # sample_data() Sample Data:       [ 53 samples by 8 sample variables ]
        # tax_table()   Taxonomy Table:    [ 8 taxa by 7 taxonomic ranks ]

phylum_melt_tum<-psmelt(prune_taxa((names(sort(taxa_sums(phylum_ps_tum), decreasing = TRUE))), phylum_ps_tum))

ggplot(phylum_melt_tum, aes(x=Sample,y=Abundance,fill=Phylum))+ 
  geom_bar(aes(fill=Phylum), stat="identity", position="fill")+theme_bw()+
  theme(text = element_text(size=12))+
  scale_fill_manual(values=c( "darkolivegreen3",  "pink", "darkolivegreen", "firebrick1",  "darkolivegreen1", "darkblue", "darkgoldenrod3",  "coral" , "dodgerblue" , "deepskyblue3", "darkorchid1","brown",  "khaki4", "lightblue1", "purple3",  "sandybrown", "darkmagenta", "saddlebrown", "palegoldenrod"))+
   facet_wrap( ~ Pred_Bailey, scales="free_x")+
   scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
   theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
   ylab("Relative abundance")+xlab("Tumor samples") +
     theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1)) +
  ggtitle("Differential Abundance analysis of PC subtypes at Phylum Level")

### Limma voom
daa_limma_tum_phylum <- run_limma_voom(ps_tumor_RA,
  group = "Pred_Bailey",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Phylum",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_tum_phylum@marker_table   ### NULL
```


### Order Level - Individual Baileys

```{r all vs all order, echo=FALSE, warning=FALSE, error = FALSE, cache=TRUE}

ps_tumor_a <- ps_tumor_RA
ps_tumor_a@sam_data$Age_scaled <- scale(ps_tumor_a@sam_data$Age)
ps_tumor_a@sam_data$Pred_Bailey <- ifelse(ps_tumor_a@sam_data$Pred_Bailey != "ADEX", "Others", ps_tumor_a@sam_data$Pred_Bailey)

ps_tumor_i <- ps_tumor_RA
ps_tumor_i@sam_data$Age_scaled <- scale(ps_tumor_i@sam_data$Age)
ps_tumor_i@sam_data$Pred_Bailey <- ifelse(ps_tumor_i@sam_data$Pred_Bailey != "Immunogenic", "Others", ps_tumor_i@sam_data$Pred_Bailey)

ps_tumor_p <- ps_tumor_RA
ps_tumor_p@sam_data$Age_scaled <- scale(ps_tumor_p@sam_data$Age)
ps_tumor_p@sam_data$Pred_Bailey <- ifelse(ps_tumor_p@sam_data$Pred_Bailey != "Progenitor", "Others", ps_tumor_p@sam_data$Pred_Bailey)

ps_tumor_s <- ps_tumor_RA
ps_tumor_s@sam_data$Age_scaled <- scale(ps_tumor_s@sam_data$Age)
ps_tumor_s@sam_data$Pred_Bailey <- ifelse(ps_tumor_s@sam_data$Pred_Bailey != "Squamous", "Others", ps_tumor_s@sam_data$Pred_Bailey)



### ADEX
ps_bailey_a <- tax_glom(ps_tumor_a, taxrank= "Order", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 16 taxa and 53 samples ]
        # sample_data() Sample Data:       [ 53 samples by 8 sample variables ]
        # tax_table()   Taxonomy Table:    [ 16 taxa by 7 taxonomic ranks ]

ord_melt_tum_a <-psmelt(prune_taxa((names(sort(taxa_sums(ps_bailey_a), decreasing = TRUE))), ps_bailey_a))

ggplot(ord_melt_tum_a, aes(x=Sample,y=Abundance,fill=Order))+ 
  geom_bar(aes(fill=Order), stat="identity", position="fill")+theme_bw()+
  theme(text = element_text(size=12))+
  scale_fill_manual(values=c("antiquewhite3", "darkblue", "brown", "coral", "darkolivegreen", "darkgoldenrod3", "gold", "firebrick1", "darkolivegreen3", "dodgerblue", "darkolivegreen1", "deepskyblue3", "darkorchid1", "khaki4", "lightblue1", "pink", "purple3",  "sandybrown", "darkmagenta", "saddlebrown", "palegoldenrod"))+
   facet_wrap( ~ Pred_Bailey, scales="free_x")+
   theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
   scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
   ylab("Relative abundance")+xlab("Tumor samples") + ggtitle("Differential Abundance Analysis - ADEX") +
     theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1))

stats_tum_ord_a <- compare_means(Abundance ~ Pred_Bailey , data = ord_melt_tum_a, paired = FALSE, group.by = "Order", method="kruskal.test")
stats_tum_ord_a

### Limma voom
daa_limma_tum_ord_a <- run_limma_voom(ps_tumor_a,
  group = "Pred_Bailey",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Order",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_tum_ord_a@marker_table



### IMMUNOGENIC
ps_bailey_i <- tax_glom(ps_tumor_i, taxrank= "Order", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 16 taxa and 53 samples ]
        # sample_data() Sample Data:       [ 53 samples by 8 sample variables ]
        # tax_table()   Taxonomy Table:    [ 16 taxa by 7 taxonomic ranks ]

ord_melt_tum_i <-psmelt(prune_taxa((names(sort(taxa_sums(ps_bailey_i), decreasing = TRUE))), ps_bailey_i))

ggplot(ord_melt_tum_i, aes(x=Sample,y=Abundance,fill=Order))+ 
  geom_bar(aes(fill=Order), stat="identity", position="fill")+theme_bw()+
  theme(text = element_text(size=12))+
  scale_fill_manual(values=c("antiquewhite3", "darkblue", "brown", "coral", "darkolivegreen", "darkgoldenrod3", "gold", "firebrick1", "darkolivegreen3", "dodgerblue", "darkolivegreen1", "deepskyblue3", "darkorchid1", "khaki4", "lightblue1", "pink", "purple3",  "sandybrown", "darkmagenta", "saddlebrown", "palegoldenrod"))+
   facet_wrap( ~ Pred_Bailey, scales="free_x")+
   theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
   scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
   ylab("Relative abundance")+xlab("Tumor samples") +
     theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1)) + 
  ggtitle("Differential Abundance Analysis - Immunogenic")

stats_tum_ord_i <- compare_means(Abundance ~ Pred_Bailey , data = ord_melt_tum_i, paired = FALSE, group.by = "Order", method="kruskal.test")
stats_tum_ord_i

### Limma voom
daa_limma_tum_ord_i <- run_limma_voom(ps_tumor_i,
  group = "Pred_Bailey",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Order",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_tum_ord_i@marker_table



### PROGENITOR
ps_bailey_p <- tax_glom(ps_tumor_p, taxrank= "Order", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 16 taxa and 53 samples ]
        # sample_data() Sample Data:       [ 53 samples by 8 sample variables ]
        # tax_table()   Taxonomy Table:    [ 16 taxa by 7 taxonomic ranks ]

ord_melt_tum_p <-psmelt(prune_taxa((names(sort(taxa_sums(ps_bailey_p), decreasing = TRUE))), ps_bailey_p))

ggplot(ord_melt_tum_p, aes(x=Sample,y=Abundance,fill=Order))+ 
  geom_bar(aes(fill=Order), stat="identity", position="fill")+theme_bw()+
  theme(text = element_text(size=12))+
  scale_fill_manual(values=c("antiquewhite3", "darkblue", "brown", "coral", "darkolivegreen", "darkgoldenrod3", "gold", "firebrick1", "darkolivegreen3", "dodgerblue", "darkolivegreen1", "deepskyblue3", "darkorchid1", "khaki4", "lightblue1", "pink", "purple3",  "sandybrown", "darkmagenta", "saddlebrown", "palegoldenrod"))+
   facet_wrap( ~ Pred_Bailey, scales="free_x")+
   theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
   scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
   ylab("Relative abundance")+xlab("Tumor samples") +
     theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1)) + 
  ggtitle("Differential abundance Analysis - Progenitor")

stats_tum_ord_p <- compare_means(Abundance ~ Pred_Bailey , data = ord_melt_tum_p, paired = FALSE, group.by = "Order", method="kruskal.test")
stats_tum_ord_p

### Limma voom
daa_limma_tum_ord_p <- run_limma_voom(ps_tumor_p,
  group = "Pred_Bailey",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Order",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_tum_ord_p@marker_table



### SQUAMOUS
ps_bailey_s <- tax_glom(ps_tumor_s, taxrank= "Order", NArm = TRUE)
        # phyloseq-class experiment-level object
        # otu_table()   OTU Table:         [ 16 taxa and 53 samples ]
        # sample_data() Sample Data:       [ 53 samples by 8 sample variables ]
        # tax_table()   Taxonomy Table:    [ 16 taxa by 7 taxonomic ranks ]

ord_melt_tum_s <-psmelt(prune_taxa((names(sort(taxa_sums(ps_bailey_s), decreasing = TRUE))), ps_bailey_s))

ggplot(ord_melt_tum_s, aes(x=Sample,y=Abundance,fill=Order))+ 
  geom_bar(aes(fill=Order), stat="identity", position="fill")+theme_bw()+
  theme(text = element_text(size=12))+
  scale_fill_manual(values=c("antiquewhite3", "darkblue", "brown", "coral", "darkolivegreen", "darkgoldenrod3", "gold", "firebrick1", "darkolivegreen3", "dodgerblue", "darkolivegreen1", "deepskyblue3", "darkorchid1", "khaki4", "lightblue1", "pink", "purple3",  "sandybrown", "darkmagenta", "saddlebrown", "palegoldenrod"))+
   facet_wrap( ~ Pred_Bailey, scales="free_x")+
   theme(axis.text.x = element_text(angle=45,hjust=1, size=3))+
   scale_y_continuous(labels = percent_format(accuracy = 1), limits = c(0, 1)) +
   ylab("Relative abundance")+xlab("Tumor samples") + ggtitle("Differential Abundance Analysis - Squamous") +
     theme (legend.position = "right",
         legend.text = element_text(size = 9), 
         legend.title = element_text(size = 10), 
         legend.key.size = unit(0.4, "cm"),  
         legend.spacing.y = unit(0.25, "cm")) +
    guides(fill = guide_legend(ncol = 1))

stats_tum_ord_s <- compare_means(Abundance ~ Pred_Bailey , data = ord_melt_tum_s, paired = FALSE, group.by = "Order", method="kruskal.test")
stats_tum_ord_s

### Limma voom
daa_limma_tum_ord_s <- run_limma_voom(ps_tumor_s,
  group = "Pred_Bailey",
  confounders = c("Sex", "Age_scaled"),
  contrast = NULL,
  taxa_rank = "Order",
  transform = "identity",
  norm = "none",
  voom_span = 0.05,
  p_adjust = c("fdr"),         
  pvalue_cutoff = 0.05)

daa_limma_tum_ord_s@marker_table
```


No differential taxonomic abundance between bailey's predicted subtypesusing limma. 


```{r association study Baileys PC and taxas, echo=FALSE}
### Association analysis of the Bailey's PC Subtypes to the different taxonomies at order rank 

predbai_taxa <- merge(mfa_df_tumor_ord[, 1, drop = FALSE], mfa_df_tumor_ord[, ((ncol(mfa_df_tumor_ord)-15):ncol(mfa_df_tumor_ord))], by = "row.names")
rownames(predbai_taxa) <- predbai_taxa$Row.names
predbai_taxa <- predbai_taxa[, -1]

predbai_taxa$Pred_Bailey <- as.factor(predbai_taxa$Pred_Bailey)

results <- list()

for (i in 2:17) {
  colname <- colnames(predbai_taxa)[i]
  test <- kruskal.test(predbai_taxa[[colname]] ~ predbai_taxa$Pred_Bailey)
  results[[colname]] <- test
}

results

pvals <- sapply(results, function(x) x$p.value)
pvals

kruskal_results <- data.frame(
  Variable = names(results),
  p.value = sapply(results, function(x) x$p.value),
  stringsAsFactors = FALSE
)

kruskal_results

```

Kruskal Wallis tests do not reveal significant differences in the relative abundances of taxonomies according to PC subtypes. 

